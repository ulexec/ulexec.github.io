<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>malware on ulexec.github.io</title>
    <link>https://ulexec.github.io/tags/malware/</link>
    <description>Recent content in malware on ulexec.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ulexec.github.io/tags/malware/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SHELF Loading</title>
      <link>https://ulexec.github.io/post/2021-04-08-shelfloading/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2021-04-08-shelfloading/</guid>
      <description>SHELF Loading is a new type of ELF binary reflective loading that my colleague @Anonymous_ and I first documented on April 21st 2021. This new ELF reflective loading methodology enables the capability to generate compiler-based artifacts with properties that resemble those of shellcode. These compiler-based artifacts are ultimately a Hybrid ELF file between conventional static and PIE binaries. Had the pleasure to publish this research at Tmp0ut, a Linux VX zine.</description>
      <content>&lt;p&gt;SHELF Loading is a new type of ELF binary reflective loading that my colleague @Anonymous_ and I first documented on April 21st 2021.
This new &lt;code&gt;ELF reflective loading&lt;/code&gt; methodology enables the capability to generate compiler-based artifacts with properties that resemble those of &lt;code&gt;shellcode&lt;/code&gt;.
These compiler-based artifacts are ultimately a &lt;code&gt;Hybrid ELF&lt;/code&gt; file between conventional static and PIE binaries.
Had the pleasure to publish this research at &lt;strong&gt;Tmp0ut&lt;/strong&gt;, a Linux VX zine. This was Volume #1, and its first release and their official site can be found at &lt;a href=&#34;http://tmpout.sh&#34;&gt;tmpout.sh&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Make sure to check other of the great articles published on this first volume if ELF mangling/golfing/fuckery is for you :)&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Over the last several years there have been several enhancements in Linux
offensive tooling in terms of sophistication and complexity. Linux malware has
become increasingly more popular, given the higher number of public reports
documenting Linux threats. These include government-backed Linux implants such
as APT28&amp;rsquo;s VPNFilter, Drovorub or Winnti wide range of Linux Malware.&lt;/p&gt;
&lt;p&gt;However, this increase in popularity does not seem to have had much of an impact
in the totality of the sophistication of the current Linux threat landscape just
yet. It&amp;rsquo;s a fairly young ecosystem, where cybercriminals have not been able to
identify reliable targets for monetization apart from Cryptocurrency Mining,
DDoS, and more recently, Ransomware operations.&lt;/p&gt;
&lt;p&gt;In today&amp;rsquo;s Linux threat landscape, even the smallest refinement or introduction
of complexity often results in AV evasion, and therefore Linux malware authors
do not tend to invest unnecessary resources to sophisticate their implants.
There are various reasons why this phenomenon occurs, and it is subject to
ambiguity. The Linux ecosystem, in contrast to other popular spheres such as
Windows and MacOS, is more dynamic and diverse, stemming from the many flavors
of ELF files for different architectures, the fact that ELF binaries can be
valid in many different forms, and that the visibility of Linux threats is often
quite poor.&lt;/p&gt;
&lt;p&gt;Due to these issues, AV vendors face a completely different set of challenges
detecting these threats. Often times this disproportionate detection failure of
simple/unsophisticated threats leaves an implicit impression that Linux malware
is by nature not complex. This statement couldn&amp;rsquo;t be further from the truth, and
those familiar with the ELF file format know that there is quite a lot of room
for innovation with ELF files that other file formats are not able to provide
due to their lack of flexibility, even if we have not seen it abused as much
over the years.&lt;/p&gt;
&lt;p&gt;In this article we are going to discuss a technique that achieves an uncommon
functionality of file formats, which generically converts full executables to
shellcode in a way that demonstrates, yet again, another example that ELF
binaries can be manipulated to achieve offensive innovation that is hard or
impossible to replicate in other file formats.&lt;/p&gt;
&lt;h2 id=&#34;a-primer-on-elf-reflective-loading&#34;&gt;A Primer On ELF Reflective Loading&lt;/h2&gt;
&lt;p&gt;In order to understand the technique, we must first give a contextual background
on previously known ELF techniques upon which this one is based, with a
comparison of the benefits and tradeoffs.&lt;/p&gt;
&lt;p&gt;Most ELF packers, or any application implementing any form of ELF binary
loading, are primarily based on what&amp;rsquo;s known as &lt;code&gt;User-Land-Exec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;User-Land-Exec is a method first documented by @thegrugq, in which an ELF binary
can be loaded without using any of the execve family of system calls, and hence
its name.&lt;/p&gt;
&lt;p&gt;For the sake of simplicity, the steps to implement an ordinary User-Land-Exec
with support of &lt;code&gt;ET_EXEC&lt;/code&gt; and &lt;code&gt;ET_DYN&lt;/code&gt; ELF binaries is illustrated in the following
diagram, showcasing an implementation of the UPX packer for ELF binaries:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.1.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;As we can observe, this technique has the following requirements (by @thegrugq):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clean out the address space&lt;/li&gt;
&lt;li&gt;If the binary is dynamically linked, load the dynamic linker.&lt;/li&gt;
&lt;li&gt;Load the binary.&lt;/li&gt;
&lt;li&gt;Initialize the stack.&lt;/li&gt;
&lt;li&gt;Determine the entry point (i.e. the dynamic linker or the main executable).&lt;/li&gt;
&lt;li&gt;Transfer execution to the entry point.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;On a more technical level, we come up with the following requirements:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Setup the stack of the embedded executable with its correspondent Auxiliary
Vector.&lt;/li&gt;
&lt;li&gt;Parse PHDR&amp;rsquo;s and identify if there is a PT_INTERP segment, denoting that
the file is a dynamically linked executable.&lt;/li&gt;
&lt;li&gt;LOAD interpreter if PT_INTERP is present.&lt;/li&gt;
&lt;li&gt;LOAD target embedded executable.&lt;/li&gt;
&lt;li&gt;Pivot to mapped e_entry of target executable or interpreter accordingly,
depending if the target executable is a dynamically linked binary.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For a more in-depth explanation, we suggest reading @thegrugq&amp;rsquo;s comprehensive
paper on the matter [9].&lt;/p&gt;
&lt;p&gt;One of the capabilities of conventional &lt;code&gt;User-Land-Exec&lt;/code&gt; are the evasion of an
execve footprint as previously mentioned, in contrast with other techniques
such as &lt;code&gt;memfd_create/execveat&lt;/code&gt;, which are also widely used to load end execute
a target ELF file. Since the loader maps and loads the target executable, the
embedded executable has the flexibility of having a non-conventional structure.
This has the side benefit of being useful for evasion and anti-forensics
purposes.&lt;/p&gt;
&lt;p&gt;On the other hand, since there are a lot of critical artifacts involved in the
loading process, it can be easy to recognize by reverse-engineers, as well as
being somewhat fragile due to the fact that the technique is heavily dependent
on these components. For this reason, writing &lt;code&gt;User-Land-Exec&lt;/code&gt; based loaders have
been somewhat tedious. As more features get added to the ELF file format, this
technique has been inclined to mature over time and thereby increasing its
complexity.&lt;/p&gt;
&lt;p&gt;The new technique that we will be covering in this paper relies on implementing
a generic &lt;code&gt;User-Land-Exec&lt;/code&gt; loader with a reduced set of constraints supporting a
hybrid &lt;code&gt;PIE&lt;/code&gt; and statically linked ELF binaries that to our knowledge have yet to
be reported.&lt;/p&gt;
&lt;p&gt;We believe this technique represents a drastic improvement of previous versions
of User-Land-Exec loaders, since based on the lack of technical implementation
constraints and the nature of this new hybrid static/PIE ELF flavor, the extent
of capabilities it can provide is wider and more evasive than with previous
&lt;code&gt;User-Land-Exec&lt;/code&gt; variants.&lt;/p&gt;
&lt;h2 id=&#34;internals-of-static-pie-executable-generation&#34;&gt;Internals Of Static PIE Executable Generation&lt;/h2&gt;
&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;
&lt;p&gt;In July of 2017 H. J. Lu patched a bug entry in GCC bugzilla named ‘Support
creating static PIE&amp;rsquo;. This patch mentioned the implementation of a statically
based PIE in his branch at glibc &lt;code&gt;hjl/pie/static&lt;/code&gt;, in which Lu documented that by
supplying &lt;code&gt;–static&lt;/code&gt; and &lt;code&gt;–pie&lt;/code&gt; flags to the linker along with &lt;code&gt;PIE&lt;/code&gt; versions of &lt;code&gt;crt*.o&lt;/code&gt;
as input, static PIE ELF executables could be generated. It is important to
note, that at the time of this patch, generation of fully statically linked &lt;code&gt;PIE&lt;/code&gt;
binaries was not possible.[1]&lt;/p&gt;
&lt;p&gt;In August, Lu submitted a second patch[2] to the GCC driver, for adding the
&lt;code&gt;–static&lt;/code&gt; flag to support &lt;code&gt;static PIE&lt;/code&gt; files that he was able to demonstrate in his
previous patch. The patch was accepted in trunk[3], and this feature was
released in GCC v8.&lt;/p&gt;
&lt;p&gt;Moreover, in December of 2017 a commit was made in glibc[4] adding the option
&lt;code&gt;–enable-static-pie&lt;/code&gt;. This patch made it possible to embed the needed parts of
ld.so to produce standalone static PIE executables.&lt;/p&gt;
&lt;p&gt;The major change in glibc to allow static PIE was the addition of the function
&lt;code&gt;_dl_relocate_static_pie&lt;/code&gt; which gets called by &lt;code&gt;__libc_start_main&lt;/code&gt;. This function is
used to locate the run-time load address, read the dynamic segment, and perform
dynamic relocations before initialization, then transfer control flow of
execution to the subject application.&lt;/p&gt;
&lt;p&gt;In order to know which flags and compilation/linking stages were needed in order
to generate static &lt;code&gt;PIE&lt;/code&gt; executables, we passed the flag &lt;code&gt;–static-pie –v&lt;/code&gt; to GCC.
However, we soon realized by doing this that the linker generated a plethora of
flags and calls to internal wrappers. As an example, the linking phase is
handled by the tool &lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/9/collect2&lt;/code&gt; and GCC itself is
wrapped by &lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/9/cc1&lt;/code&gt;. Nevertheless, we managed to
remove the irrelevant flags and we ended up with the following steps:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.2.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;These steps are in fact the same provided by Lu, supplying the linker with input
files compiled with &lt;code&gt;–fpie&lt;/code&gt;, and &lt;code&gt;–static, -pie, -z text, --no-dynamic-linker&lt;/code&gt;.
In particular, the most relevant artifacts for static PIE creation are &lt;code&gt;rcrt1.o&lt;/code&gt;,
&lt;code&gt;libc.a&lt;/code&gt;, and our own supplied input file, &lt;code&gt;test.o&lt;/code&gt;. The &lt;code&gt;rcrt1.o&lt;/code&gt; object contains the
&lt;code&gt;_start&lt;/code&gt; code which has the code required to correctly load the application before
executing its entry point by calling the correspondent libc startup code
contained in &lt;code&gt;__libc_start_main&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.3.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;As previously mentioned, &lt;code&gt;__libc_start_main&lt;/code&gt; will call the new added function
&lt;code&gt;_dl_relocate_static_pie&lt;/code&gt; (defined at &lt;code&gt;elf/dl-reloc-static-pie.c&lt;/code&gt; file of glibc
source). The primary steps performed by this function are commented in the
source:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.4.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;With the help of these features, GCC is capable of generating static executables
which can be loaded at any arbitrary address.&lt;/p&gt;
&lt;p&gt;We can observe that &lt;code&gt;_dl_relocate_static_pie&lt;/code&gt; will handle the needed dynamic
relocations. One noticeable difference of &lt;code&gt;rcrt1.o&lt;/code&gt; from conventional &lt;code&gt;crt1.o&lt;/code&gt; is
that all contained code is position independent. Inspecting what the generated
binaries look like we see the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.5.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;At first glance they seem to be common dynamically linked PIE executables, based
on the &lt;code&gt;ET_DYN&lt;/code&gt; executable type retrieved from the ELF header. However, upon
closer examination of the segments, we will observe the nonexistent &lt;code&gt;PT_INTERP&lt;/code&gt;
segment usually denoting the path to the interpreter in dynamically linked
executables and the existence of a &lt;code&gt;PT_TLS&lt;/code&gt; segment, usually contained only in
statically linked executables.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.6.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we check what the dynamic linker identifies the subject executable as, we
will see it identifies the file type correctly:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.7.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;In order to load this file, all we would need to do is map all the &lt;code&gt;PT_LOAD&lt;/code&gt;
segments to memory, set up the process stack with the correspondent &lt;code&gt;Auxiliary Vector&lt;/code&gt; entries, and then pivot to the mapped executable&amp;rsquo;s entry point. We do
not need to be concerned about mapping the &lt;code&gt;RTLD&lt;/code&gt; since we don&amp;rsquo;t have any external
dependencies or link time address restrictions.&lt;/p&gt;
&lt;p&gt;As we can observe, we have four loadable segments commonly seen in &lt;code&gt;SCOP ELF  binaries&lt;/code&gt;. However, for the sake of easier deployment, it will be crucial if we
could merge all those segments into one as is usually done with ELF disk
injection into a foreign executable. We can do just this by using the &lt;code&gt;–N&lt;/code&gt; linker
flag to merge data and text within a single segment.&lt;/p&gt;
&lt;h3 id=&#34;non-compatibility-of-gccs--n-and-static-pie-flags&#34;&gt;Non-compatibility of GCC&amp;rsquo;s -N and static-pie flags&lt;/h3&gt;
&lt;p&gt;If we pass &lt;code&gt;–static-pie&lt;/code&gt; and &lt;code&gt;–N&lt;/code&gt; flags together to GCC we see that it generates the
following executable:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.8.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The first thing we noticed about the type of generated ELF when using
&lt;code&gt;–static-pie&lt;/code&gt; alone was that it had a type of &lt;code&gt;ET_DYN&lt;/code&gt;, and now together with &lt;code&gt;–N&lt;/code&gt; it
results in an &lt;code&gt;ET_EXEC&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In addition, if we take a closer look at the segment&amp;rsquo;s virtual addresses, we see
that the generated binary is not a Position Independent Executable. This is due
to the fact that the virtual addresses appear to be absolute addresses and not
relative ones. To understand why our program is not being linked as expected, we
inspected the linker script that was being used.&lt;/p&gt;
&lt;p&gt;As we are using the ld linker from binutils, we took a look on how ld selected
the linker script; this is done in the &lt;code&gt;ld/ldmain.c&lt;/code&gt; code at line 345:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.9.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ldfile_open_default_command_file&lt;/code&gt; is in fact an indirect call to an
architecture independent function generated at compile time that contains a set
of internal linker scripts to be selected depending upon the flags passed to ld.
Because we are using the x86_64 architecture, the generated source will be
&lt;code&gt;ld/elf_x86_64.c&lt;/code&gt;, and the function which is called to select the script is
&lt;code&gt;gldelf_x86_64_get_script&lt;/code&gt;, which is simply a set of if-else-if statements to
select the internal linker script. The &lt;code&gt;–N&lt;/code&gt; option sets the config.text_read_only
variable to false, which forces the selection function to use an internal script
which does not produce PIC as can be seen below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.10.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;This way of selecting the default script makes the &lt;code&gt;–static-pie&lt;/code&gt; and &lt;code&gt;–N&lt;/code&gt; flags
non-compatible, because the forced test of selecting the script based on –N is
parsed before &lt;code&gt;–static-pie&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;circumvention-via-custom-linker-script&#34;&gt;Circumvention via custom Linker Script&lt;/h3&gt;
&lt;p&gt;The incompatibility between &lt;code&gt;–N&lt;/code&gt;, &lt;code&gt;-static&lt;/code&gt;, and &lt;code&gt;–pie&lt;/code&gt; flags led us to a dead end,
and we were forced to think of different ways to overcome this barrier. What we
attempted was to provide a custom script to drive the linker. As we essentially
needed to merge the behavior of two separate linker scripts, our approach was to
choose one of the scripts and adapt it to generate the desired outcome with
features of the remaining script.&lt;/p&gt;
&lt;p&gt;We chose the default script of &lt;code&gt;–static-pie&lt;/code&gt; over the one used with &lt;code&gt;–N&lt;/code&gt; because in
our case it was easier to modify as opposed to changing the –N default script to
support PIE generation.&lt;/p&gt;
&lt;p&gt;To accomplish this goal, we would need to change the definition of the segments,
which are controlled by the &lt;code&gt;PHDRS&lt;/code&gt; [5] field in the linker script. If the command
is not used the linker will provide program headers generated by default –
However, if we neglect this in the linker script, the linker will not create any
additional program headers and will strictly follow the guidelines defined in
the subject linker script.&lt;/p&gt;
&lt;p&gt;Taking into account the details discussed above, we added a PHDRS command to the
default linker script, starting with all the original segments which are created
by default when using &lt;code&gt;–static-pie&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.11.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;After this we need to know how each section maps to each segment – and for this
we can use readelf as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.12.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;With knowledge of the mappings, we just needed to change the section output
definition in the linker script which adds the appropriate segment name at the
end of each function definition, as shown in the following example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.13.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here, the .tdata and .tbss sections are being assigned to the segments that get
mapped in the same order that we saw in the output of the readelf –l command.
Eventually, we ended up having a working script precisely changing all mapped
sections which were mapped in data to the text segment:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.14.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we compile our subject test file with this linker script, we see the
following generated executable:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.15.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;We now have a static-pie with just one loadable segment. The same approach can
be repeated to remove other irrelevant segments, keeping only critical segments
necessary for the execution of the binary. As an example, the following is a
static-pie executable instance with minimal program headers needed to run:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.16.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The following is the final output of our desired ELF structure – having only one
PT_LOAD segment generated by a linker script with the PHDRS command configured
as in the screenshot below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.17.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;shelf-loading&#34;&gt;SHELF Loading&lt;/h2&gt;
&lt;p&gt;This generated ELF flavor gives us some interesting capabilities that other ELF
types are not able to provide. For the sake of simplicity, we have labelled this
type of ELF binary as SHELF, and we will be referencing it throughout the rest
of this paper. The following is an updated diagram of the loading stages needed
for SHELF loading:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.18.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;As we can see in the diagram above, the process of loading SHELF files is highly
reduced in complexity compared to conventional ELF loading schemes.&lt;/p&gt;
&lt;p&gt;To illustrate the reduced set of constraints to load these types of files, a
snippet of a minimalistic SHELF User-Land-Exec approach is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.19.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;By using this approach, a subject SHELF file would look as follows in memory and
on disk:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.20.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;As we can observe, the ELF header and Program Headers are missing from the
process image. This is a feature that this flavor of ELF enables us to implement
and is discussed in the following section.&lt;/p&gt;
&lt;h3 id=&#34;anti-forensic-capabilities&#34;&gt;Anti-Forensic Capabilities&lt;/h3&gt;
&lt;p&gt;This new approach to &lt;code&gt;User-Land-Exec&lt;/code&gt; has also two optional stages useful for
anti-forensic purposes. Since the &lt;code&gt;dl_relocate_static_pie&lt;/code&gt; function will obtain
all of the required fields for relocation from the Auxiliary Vector, this leaves
us room to play with how the subject &lt;code&gt;SHELF&lt;/code&gt; file structure may look in memory and
on disk.&lt;/p&gt;
&lt;p&gt;Removing the ELF header will directly impact reconstruction capabilities,
because most Linux-based scanners will scan process memory for existing ELF
images by first identifying ELF headers. The ELF header will be parsed and will
contain further information on where to locate the Program Header Table and
consequently the rest of the mapped artifacts of the file.&lt;/p&gt;
&lt;p&gt;Removal of the ELF header is trivial since this artifact is not really needed by
the loader – all required information in the subject file will be retrieved from
the &lt;code&gt;Auxiliary Vector&lt;/code&gt; as previously mentioned.&lt;/p&gt;
&lt;p&gt;An additional artifact that can be hidden is the Program Header Table. This is a
slightly different case when compared with the ELF Header. The &lt;code&gt;Auxiliary Vector&lt;/code&gt;
needs to locate the Program Header Table in order for the &lt;code&gt;RTLD&lt;/code&gt; to successfully
load the file by applying the needed runtime relocations. Regardless, there are
many approaches to obfuscating the &lt;code&gt;PHT&lt;/code&gt;. The simplest approach is to remove the
original &lt;code&gt;Program Header Table&lt;/code&gt; location, and relocate it somewhere in the file
that is only known by the &lt;code&gt;Auxiliary Vector&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.21.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can precompute the location of each of the &lt;code&gt;Auxiliary Vector&lt;/code&gt; entries and
define each entry as a macro in an include file, tailoring our loader to every
subject SHELF file at compile-time. The following is an example of how these
macros can be generated:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.22.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;As we can observe, we have parsed the subject &lt;code&gt;SHELF&lt;/code&gt; file for its e_entry and
e_phnum fields, creating corresponding macros to hold those values. We also have
to choose a random base image to load the file. Finally, we locate the PHT and
convert it to an array, then remove it from its original location. Applying
these modifications allows us to completely remove the ELF header and change the
default location of the subject &lt;code&gt;SHELF&lt;/code&gt; file PHT both on disk and in memory(!)&lt;/p&gt;
&lt;p&gt;Without successful retrieval of the &lt;code&gt;Program Header Table&lt;/code&gt;, reconstruction
capabilities may be strictly limited and further heuristics will have to be
applied for successful process image reconstruction.&lt;/p&gt;
&lt;p&gt;An additional approach to make the reconstruction of the Program Header Table
much harder is by instrumenting the way glibc implements the resolution of the
Auxiliary Vector fields.&lt;/p&gt;
&lt;h3 id=&#34;obscuring-shelf-features-by-pt_tls-patching&#34;&gt;Obscuring SHELF features by PT_TLS patching&lt;/h3&gt;
&lt;p&gt;Even after modifying the default location of the &lt;code&gt;Program Header Table&lt;/code&gt; by
choosing a new arbitrary location when crafting the &lt;code&gt;Auxiliary Vector&lt;/code&gt;, the
Program Header Table would still reside in memory and could be found with some
effort. To obscure ourselves even further we can cover how the startup code
reads the &lt;code&gt;Auxiliary Vector&lt;/code&gt; fields.&lt;/p&gt;
&lt;p&gt;The code that does this is in &lt;code&gt;elf/dl_support.c&lt;/code&gt; in the function &lt;code&gt;_dl_aux_init&lt;/code&gt;. In
abstract, the code iterates over all the &lt;code&gt;auxv_t&lt;/code&gt; entries, and each of these
entries initialize internal variables from glibc:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.23.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The only reason the Auxiliary Vector is required is to initialize internal &lt;code&gt;_dl_*&lt;/code&gt;
variables. Knowing this, we can bypass the creation of the &lt;code&gt;Auxiliary Vector&lt;/code&gt;
entirely and do the same job that &lt;code&gt;_dl_aux_init&lt;/code&gt; would do before passing control
of execution to the subject &lt;code&gt;SHELF&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;The only entries which are critical are &lt;code&gt;AT_PHDR&lt;/code&gt;, &lt;code&gt;AT_PHNUM&lt;/code&gt;, and &lt;code&gt;AT_RANDOM&lt;/code&gt;.
Therefore, we only need to patch the respective &lt;code&gt;_dl_*&lt;/code&gt; variables that depend on
these fields. As an example of how to retrieve these values, we can use the
following one-liner to generate an include file with precomputed macros holding
the offset to every &lt;code&gt;dl_*&lt;/code&gt; variable:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.24.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;With the offset to these variables located, we only need to patch them in the
same way the original startup code would do so using the &lt;code&gt;Auxiliary Vector&lt;/code&gt;. As a
way to illustrate this technique, the following code will initialize the
addresses of the &lt;code&gt;Program Headers&lt;/code&gt; to &lt;code&gt;new_address&lt;/code&gt;, and the number of program
headers to the correct number:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.25.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;At this point we have a working program without supplying the &lt;code&gt;Auxiliary Vector&lt;/code&gt;.
Because the subject binary is &lt;code&gt;statically linked&lt;/code&gt;, and the code that will load the
&lt;code&gt;SHELF&lt;/code&gt; file is our loader, we can neglect every other segment in the Auxiliary
Vector&amp;rsquo;s &lt;code&gt;AT_PHDR&lt;/code&gt; and &lt;code&gt;AT_PHNUM&lt;/code&gt; or &lt;code&gt;dl_phdr&lt;/code&gt; and &lt;code&gt;dl_phnum&lt;/code&gt; respectively. There is an
exception, which is the &lt;code&gt;PT_TLS&lt;/code&gt; segment which is the interface in which Thread
Local Storage is implemented in the ELF file format.&lt;/p&gt;
&lt;p&gt;The following code which resides in &lt;code&gt;csu/libc-tls.c&lt;/code&gt; on function &lt;code&gt;__libc_setup_tls&lt;/code&gt;
show the type of information that gets retrieved from the &lt;code&gt;PT_TLS&lt;/code&gt; segment:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.26.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the code snippet above, we can see that TLS initialization relies on the
presence of the &lt;code&gt;PT_TLS&lt;/code&gt; segment. We have several approaches that can obfuscate
this artifact, such as patching the &lt;code&gt;__libc_setup_tls&lt;/code&gt; function to just return and
then initialize the TLS with our own code. Here, we&amp;rsquo;ll choose to implement a
quick patch to glibc instead as a PoC.&lt;/p&gt;
&lt;p&gt;To avoid the need of the &lt;code&gt;PT_TLS&lt;/code&gt; Program Header we have added a global variable
to hold the values from &lt;code&gt;PT_TLS&lt;/code&gt; and set the values inside &lt;code&gt;__libc_setup_tls&lt;/code&gt;,
reading from our global variable instead of the subject &lt;code&gt;SHELF&lt;/code&gt; file Program
Header Table. With this small change we finally strip all the program headers:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.27.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using the following script to generate &lt;code&gt;_phdr.h&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.28.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can apply our patches in the following way after including &lt;code&gt;_phdr.h&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.29.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Applying the methodology shown above, we gain a high level of evasiveness by
loading and executing our &lt;code&gt;SHELF&lt;/code&gt; file without an ELF header, Program Header
Table, and &lt;code&gt;Auxiliary Vector&lt;/code&gt; – just as shellcode gets loaded. The following
diagram illustrates how straightforward the loading process of &lt;code&gt;SHELF&lt;/code&gt; files is:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tmpout.sh/1/10/10.30.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We have covered the internals of Reflective Loading of ELF files, explaining
previous implementations of User-Land-Exec, along with its benefits and
drawbacks. We then explained the latest patches in the GCC code base that
implemented support for static-pie binaries, discussing our desired outcome,
and the approaches we followed to achieve the generation of static-pie ELF files
with one single PT_LOAD segment. Finally, we discussed the anti-forensic
features that SHELF loading can provide, which we think to be a considerable
enhancement when compared with previous versions of ELF Reflective Loading.&lt;/p&gt;
&lt;p&gt;We think this could be the next generation of ELF Reflective Loading, and it may
benefit readers to understand the extent of offensive capabilities that the ELF
file format can provide. If you would like access to the source code, contact
@sblip or @ulexec.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] (support static pie)
&lt;a href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81498&#34;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81498&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] (first patch gcc)
&lt;a href=&#34;https://gcc.gnu.org/ml/gcc-patches/2017-08/msg00638.html&#34;&gt;https://gcc.gnu.org/ml/gcc-patches/2017-08/msg00638.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] (gcc patch)
&lt;a href=&#34;https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;amp;revision=252034&#34;&gt;https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;amp;revision=252034&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] (glibc &amp;ndash;enable-static-pie)
&lt;a href=&#34;https://sourceware.org/git/?p=glibc.git;a=commit;&#34;&gt;https://sourceware.org/git/?p=glibc.git;a=commit;&lt;/a&gt; &lt;br&gt;
h=9d7a3741c9e59eba87fb3ca6b9f979befce07826&lt;/li&gt;
&lt;li&gt;[5] (ldscript doc)
&lt;a href=&#34;https://sourceware.org/binutils/docs/ld/PHDRS.html#PHDRS&#34;&gt;https://sourceware.org/binutils/docs/ld/PHDRS.html#PHDRS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] &lt;a href=&#34;https://sourceware.org/binutils/docs/ld/&#34;&gt;https://sourceware.org/binutils/docs/ld/&lt;/a&gt;
Output-Section-Phdr.html#Output-Section-Phdr&lt;/li&gt;
&lt;li&gt;[7] &lt;a href=&#34;https://www.akkadia.org/drepper/tls.pdf&#34;&gt;https://www.akkadia.org/drepper/tls.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[8] (why ld doesn&amp;rsquo;t allow -static -pie -N)
&lt;a href=&#34;https://sourceware.org/git&#34;&gt;https://sourceware.org/git&lt;/a&gt; &lt;br&gt;
/gitweb.cgi?p=binutils-gdb.git;a=blob;f=ld/ldmain.c; &lt;br&gt;
h=c4af10f4e9121949b1b66df6428e95e66ce3eed4;hb=HEAD#l345&lt;/li&gt;
&lt;li&gt;[9] (grugq ul_exec paper)
&lt;a href=&#34;https://grugq.github.io/docs/ul_exec.txt&#34;&gt;https://grugq.github.io/docs/ul_exec.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[10] (ELF UPX internals)
&lt;a href=&#34;https://ulexec.github.io/ulexec.github.io/article&#34;&gt;https://ulexec.github.io/ulexec.github.io/article&lt;/a&gt; &lt;br&gt;
/2017/11/17/UnPacking_a_Linux_Tsunami_Sample.html&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Tales Of Binary Deobfuscation</title>
      <link>https://ulexec.github.io/post/2020-03-03-deobfuscation_1/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2020-03-03-deobfuscation_1/</guid>
      <description>This article is going to serve as my personal reference on this topic. Since I&amp;rsquo;ve always wanted to write about it and just finished Yuma Kurogome&amp;rsquo;s course on Advance Binary Deobfuscation, I thought it would be a good time to write notes regarding what I learned in this course with a fresh state of mind on the subject matter for future reference.
Introduction There are close to 31 known code transformations.</description>
      <content>&lt;p&gt;This article is going to serve as my personal reference on this topic. Since I&amp;rsquo;ve always wanted to write about it and just finished Yuma Kurogome&amp;rsquo;s course on &lt;a href=&#34;https://github.com/malrev/ABD&#34;&gt;Advance Binary Deobfuscation&lt;/a&gt;, I thought it would be a good time to write notes regarding what I learned in this course with a fresh state of mind on the subject matter for future reference.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;There are close to 31 known &lt;a href=&#34;https://mediatum.ub.tum.de/doc/1367533/1367533.pdf&#34;&gt;code transformations&lt;/a&gt;. However, In this article we will focus on grouping these transformation in categories based on their behavior, and we will cover some of the most relevant techniques today on a conceptual point of view.
We will be also covering practical approaches to the aforementioned techniques using the reverse engineering framework MIASM (0.1.3.dev39).&lt;/p&gt;
&lt;p&gt;Despite the large number of transformations, obfuscation techniques can be group up into 3 different categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Confusion oriented:
&lt;ul&gt;
&lt;li&gt;Unreachable Code Insertion&lt;/li&gt;
&lt;li&gt;Dead Code Insertion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Syntax Modification
&lt;ul&gt;
&lt;li&gt;Instruction Substitution&lt;/li&gt;
&lt;li&gt;Constant Folding/Unfolding&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Semantic Modification
&lt;ul&gt;
&lt;li&gt;Opaque Predicates&lt;/li&gt;
&lt;li&gt;Range Dividers&lt;/li&gt;
&lt;li&gt;Virtualization&lt;/li&gt;
&lt;li&gt;Control Flow Flattening&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will be discussing each of these techniques on a conceptual level, although we will be also covering practical examples.
The purpose of this article is to crystallize concepts instead of being a strict technical reference, although further technical reading will be linked all throughout the article along with practical implementations on how to remediate some of these techniques.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;In this section we will be covering 3 different transformations which have a close correlation between one another, and consequently a similar approach for circumvention.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Unreachable Code&lt;/strong&gt;: is defined as inserted code into a target application which is never going to be executed, serving the purpose of an unexpensive way of distracting the analyst for a few minutes.
an example of Junk code is the following:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;jz&lt;/span&gt; loc_key1      &lt;span style=&#34;color:#75715e&#34;&gt;; lets imagine this conditional branch is not really conditional&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt; eax, eax     &lt;span style=&#34;color:#75715e&#34;&gt;; * this will never execute&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pushf&lt;/span&gt; 	         &lt;span style=&#34;color:#75715e&#34;&gt;; *&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt; ebx          &lt;span style=&#34;color:#75715e&#34;&gt;; *&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;and&lt;/span&gt; ebx, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;; *&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt; ebx, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;; *&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;je&lt;/span&gt; loc_key2      &lt;span style=&#34;color:#75715e&#34;&gt;; *&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;loc_key1:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dead Code&lt;/strong&gt;: is defined as inserted code into a target application which, although it may be executed, it does not change the original control flow of the program.
Again this technique&amp;rsquo;s pupose is to just confuse the analyst to make him/her spend a bit more time understanding the purpose of the aforementioned instructions.
The following is an example:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; edx, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xdeadc00d&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;; * this specific instruction is deadcode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; eax, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; ecx, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; edx, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;; * edx gets overriden here, also deadcode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_4], ecx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_8], eax&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Instruction Substitution&lt;/strong&gt;: defined as to replace a given set of instructions with another more complex set of instructions with identical semantic meaning. This kind of techniques have been heavely employed by metamorphic code engines in the past and may highly affect the legibility of the affected code.
Lets imagine that originally we have the following set of instructions:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; eax, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; eax, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_C]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; eax, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_10]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; eax, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_4]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;This set of instruction can be transform to the following one, being much harder to interpret and understand having the same semantic meaning:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; eax, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_C]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; edx, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_10]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt; eax, &lt;span style=&#34;color:#ae81ff&#34;&gt;2598A32Bh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; eax, edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; eax, &lt;span style=&#34;color:#ae81ff&#34;&gt;2598A32Bh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; edx, [ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; esi, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt; esi, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; eax, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt; eax, edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; esi, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; eax, ecx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt; eax, esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt; edx,[ebp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt; ecx, edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt; eax, ecx&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;circumvention&#34;&gt;Circumvention&lt;/h3&gt;
&lt;p&gt;In order to mitigate these transformations we can do a variety of techniques based on Data Flow Analysis. Before we introduce these techniques, is important to understand that in order to succesfully implement Data Flow Analysis strategies we have to rely on a Intermediate Representation of the subject code. Compilers also rely on IRs to apply their program synthesis and code optimitations capabilities. In other words, We can deobfuscate these transformations by using the same techniques used by compilers for
their own optimization purposes.&lt;/p&gt;
&lt;p&gt;These techniques are the following:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;reachable-definition-analysis&#34;&gt;Reachable Definition Analysis&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Forward dataflow analysis&lt;/li&gt;
&lt;li&gt;Analyze where the value of each variable was defined when a certain point in the program was reached&lt;/li&gt;
&lt;li&gt;Application:
&lt;ul&gt;
&lt;li&gt;Constant propagation/folding&lt;/li&gt;
&lt;li&gt;Transform expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An overview of how Reachability Analysis work can be shown in the following picture from Yuma&amp;rsquo;s Course:
&lt;img src=&#34;https://ulexec.github.io/Reachability_Analysis.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;liveless-analysis&#34;&gt;Liveless Analysis&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Backward dataflow analysis&lt;/li&gt;
&lt;li&gt;Analyze whether the value x in the program point p may be used when following the edge starting from p in the flow graph with respect to x&lt;/li&gt;
&lt;li&gt;Application:
&lt;ul&gt;
&lt;li&gt;Dead code elimination&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An overview of how Liveless Analysis work can be shown in the following picture from Yuma&amp;rsquo;s Course:
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Liveless_Analysis.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Both reachable definition analysis and liveness analysis are IR optimization techniques used by a compiler backend, and are also useful for binary analysis.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;practical-example-deobfuscating-ollvms-instruction-substitution-pass&#34;&gt;Practical Example. Deobfuscating OLLVM&amp;rsquo;s Instruction Substitution Pass&lt;/h4&gt;
&lt;p&gt;For this example we will be using the given example compiled with o-llvm -sub flag to enable OLLVM&amp;rsquo;s Intruction Substitution Pass.&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;target_function&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a,b,c,r;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;56&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; argv[]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;target_function&lt;/span&gt;(argc);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;n=%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;Both target_functions before and after obfuscation look like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/inst_sub_r2.png#center&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Since we need a framework to lift the code to an IR to apply these types of optimization analyses, we can use MIASM&amp;rsquo;s Data Flow Analysis modules to deobfuscate transformations such as instruction substitution, dead/junk code or constant unfolding.&lt;/p&gt;
&lt;p&gt;MIASM has a simple way of retrieving and lifting the subject function to MIASM IR:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Opening Target File and Storing it in a &amp;#39;Container&amp;#39; Object&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cont &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Container&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_stream(open(args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;target, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Instantiating disassembler&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;machine &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Machine(args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;architecture &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;architecture &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; cont&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;arch)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dis &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; machine&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis_engine(cont&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bin_stream, loc_db&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;cont&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Disassembling and Extracting CFG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;asmcfg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis_multiblock(int(args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addr, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Extracting IR archive and IRCFG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ir_arch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; machine&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ira(cont&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ircfg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ir_arch&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new_ircfg_from_asmcfg(asmcfg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Simplifying IR&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;deadrm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DeadRemoval(ir_arch)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;entry_points &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set([dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_offset_location(args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addr)])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;init_infos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ir_arch&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;arch&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;regs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;regs_init
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cst_propag_link &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; propagate_cst_expr(ir_arch, ircfg, args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addr, init_infos)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# deadrm(ircfg)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# remove_empty_assignblks(ircfg)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# This line simplifies the IR with the same features as above and more&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;simplify(expr_simp_high_to_explicit)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
At this point we will be able to optimise the given subject function and consequently mitigate the aforementioned obfuscation techniques. In order to show the result in a more readable format, it would be nice to transform the optimized IR function representation back to x86, the original architecture we compiled our test case.
Unfortunatelly, MIASM&amp;rsquo;s IR is not backwards compatible with x86, however MIASM provide capabilities to translate MIASM&amp;rsquo;s IR to LLVM IR to then retrieve back the optimized subject function in its native representation.&lt;/p&gt;
&lt;p&gt;In order to do this we can do the following:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Instantiate an LLVM context and Function to fill&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;context &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LLVMContext_IRCompilation()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;context&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ir_arch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ir_arch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;func &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LLVMFunction_IRCompilation(context, name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;func&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ret_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; llvm_ir&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;VoidType()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;func&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;init_fc()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# IRCFG is imported, without the final &amp;#34;ret void&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;func&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_ircfg(ircfg, append_ret&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Finish the function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;func&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;builder&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ret_void()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Parsing LLVM IR&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;M &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parse_assembly(str(func))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;M&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;verify()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Initialising Native Exporter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;initialize()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;initialize_native_target()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;initialize_native_asmprinter()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Optimisation to clean value computation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pmb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;create_pass_manager_builder()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pmb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;opt_level &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;create_module_pass_manager()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pmb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;populate(pm)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;run(M)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Generate Binary output&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Target&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_default_triple()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_triple(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;i386-pc-linux-gnu&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target_machine &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;create_target_machine()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;obj_bin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target_machine&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;emit_object(M)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;obj &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; llvm&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ObjectFileRef&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_data(obj_bin)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.o&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;target, hex(int(args&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addr, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(obj_bin)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;The full script can be downloaded &lt;a href=&#34;https://github.com/ulexec/ulexec.github.io/raw/master/files/optimize.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After running the previous script, we will see it will generate an ET_REL type ELF file containing the native version of our deobfuscated function by optimization.
The following is the result of this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/deobfuscated_func.png#center&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;As we can see in the previous screenshot, there is some dead code resident in the optimized function. This dead code represents the local variables used in the obfuscated (and original) version of the function.&lt;/p&gt;
&lt;p&gt;Data Flow Analysis and optimizations are restricted to memory writes along with other constraints such as variables involved in conditional jumps.
Despite this, we can clearly see that Data Flow Analysis can be very effective for instruction subtitution deobfuscation giving us a simplified version of what the function may have looked like after and even before obfuscation.&lt;/p&gt;
&lt;p&gt;As we mentioned there are some additional contraints while removing some of the dead code after simplification, such as memory writes or variables needed for conditional branches. In regards to conditional branches, in the next section we will cover the concept of opaque predicates and what we can do to indentify and mitigate them.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;opaque-predicates&#34;&gt;Opaque Predicates&lt;/h2&gt;
&lt;p&gt;Opaque predicates in a nutshell is a commonly used technique in code obfuscation intended to add complexity to control flow usually implemented as conditional branches although these conditional branches have a deterministic control flow.&lt;/p&gt;
&lt;p&gt;A simple example of what opaque predicates are can be shown in the following C code:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;argv) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b) {        &lt;span style=&#34;color:#75715e&#34;&gt;// opaque predicate
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;puts&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;This is never going to execute&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;puts&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;predifined control flow&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;		
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
The previous C snippet is an over-simplified opaque predicate example, however its important to illustrate the concept we are trying to tackle. As we can see in the  example, a and b local variables are never going to satisfy the equality condition of the if statement since the values of a and b are not dependant on function&amp;rsquo;s input, therefore the condition itself is not prone to change.&lt;/p&gt;
&lt;p&gt;This same concept can be extrapolated to more complex equalities/conditions usually appearing in high volume on a subject obfuscated application.
Depending on the implementation sophistication of this technique, control flow clarity can be highly affected and therefore the interpretation and time of analysis of a subject application.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;circumvention-1&#34;&gt;Circumvention&lt;/h3&gt;
&lt;p&gt;One approach to identify opaque predicates is to use Symbolic Execution along with an SMT solver in order to check feasibility on conditional branches.&lt;/p&gt;
&lt;p&gt;How it works:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Execute a program sequentially while treating input values as symbols that represent all possible values.&lt;/li&gt;
&lt;li&gt;Add constraints on symbols.
&lt;ul&gt;
&lt;li&gt;Path Constraint: Constraints to execute a path.&lt;/li&gt;
&lt;li&gt;Symbolic Store: Updated symbol information.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When the target address of the conditional jump is reached, solve the constraints with a SMT solver and get a concrete input value.
&lt;ul&gt;
&lt;li&gt;Need to convert IR to SMT solver-acceptable expressions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Opaque predicates have a deterministic feasibility regardless of input values.
Therefore, we can invoke a SMT solver at every conditional branch and verify whether there is an input value that evaluates the condition to a True or False result.
If a subject conditional branch is not dependant on a input value the branch should be an opaque predicate.
We can apply the technique discussed above and attempt to detect opaque predicates via Symbolic Execution + SMT solver.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;practical-example-deobfuscating-x-tunnel-opaque-predicates&#34;&gt;Practical Example. Deobfuscating X-Tunnel Opaque Predicates&lt;/h4&gt;
&lt;p&gt;The binary file we are going to use for this example is the following:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;X&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Tunnel: a979c5094f75548043a22b174aa10e1f2025371bd9e1249679f052b168e194b3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
The first thing we have to do is to write a path exploration function based on Symbolic Execution.
We can do this with MIASM as follows:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;explore&lt;/span&gt;(ir, start_addr, start_symbols,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ircfg, cond_limit&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, uncond_limit&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lbl_stop&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, final_states&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[]):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codepath_walk&lt;/span&gt;(addr, symbols, conds, depth, final_states, path):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# Instantiate MIASM Symbolic Execution Engine&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SymbolicExecutionEngine(ir, symbols)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(uncond_limit):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isinstance(addr, ExprInt):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# recursion delimiter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; addr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_get_int() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; lbl_stop:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    final_states&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(FinalState(&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;, sb, conds, path))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# Append all executed Paths&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(addr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# Run Symbolic Engine at block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            pc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;run_block_at(ircfg, addr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# if IR expression is a condition&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isinstance(pc, ExprCond):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# Create conditions that satisfy true or false paths&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                cond_true  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {pc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cond: ExprInt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                cond_false &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {pc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cond: ExprInt(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# Compute the destination addr of the true or false paths&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                addr_true  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expr_simp(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;eval_expr(pc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;replace_expr(cond_true), {}))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                addr_false &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expr_simp(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;eval_expr(pc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;replace_expr(cond_false), {}))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# Adding previous conditions of previous&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# blocks in path to satisfy reachability of current block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                conds_true &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(conds) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; list(cond_true&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                conds_false &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(conds) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; list(cond_false&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# Check feasibility of True condition on conditional branch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; check_path_feasibility(conds_true):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# If True path is feasible, continue with Symbolic Execution&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    codepath_walk(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        addr_true, sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;symbols&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;copy(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        conds_true, depth &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, final_states, list(path))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# If not, store the current block and stop recursion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    final_states&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(FinalState(&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;, sb, conds_true, path))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; check_path_feasibility(conds_false):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# If False path is feasible, continue with Symbolic Execution&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    codepath_walk(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        addr_false, sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;symbols&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;copy(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        conds_false, depth &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, final_states, list(path))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# If not, store the current block and stop recursion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    final_states&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(FinalState(&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;, sb, conds_false, path))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# If current IR expression is not a Condition,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# simplify block expresion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expr_simp(sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;eval_expr(pc))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# Append Final state&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        final_states&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(FinalState(&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;, sb, conds, path))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Start by walking function from its start address&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; codepath_walk(start_addr, start_symbols, [], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, final_states, [])&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
As seen in the previous snippet, the overall steps of our path exploration algorithm are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Symbolically Execute every block in current function until it finds a conditional IR expression (which would be the same as a conditional instruction in its native representation).&lt;/li&gt;
&lt;li&gt;Once this conditional expression is reached, we then evaluate both the branch destination address if the condition would be satisfied and if it wouldn&amp;rsquo;t accordingly.&lt;/li&gt;
&lt;li&gt;When we have identified the two different branch addresses, then we compute the feasibility of each subject branch (which includes all previous conditions to reach to the designated destination address) and if its feasible we continue symbolically executing the branch. If not we mark that current path as finished and we store it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The feasibility of the branch condition can be done via MIASM&amp;rsquo;s z3 SMT Solver Translator:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;check_path_feasibility&lt;/span&gt;(conds):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    solver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; z3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Solver()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lval, rval &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; conds:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        z3_cond &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Translator&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;to_language(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;z3&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_expr(lval)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        solver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(z3_cond &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; int(rval&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;arg))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rslt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; solver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;check()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; rslt &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; z3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sat:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
After Symbolic Execution of our target function is done, we will have an array of all of the stored final states of each path in the function.
These final states will contained every executed block.
In order to identify blocks which have not been executed, we do the following:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# The IR nodes in final_states array are the path nodes that were executed.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# We collect the &amp;#39;lock_key&amp;#39; or block labels of each of the nodes executed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; final_state &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; final_states:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; final_state&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;result:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; final_state&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path_history:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isinstance(node, int):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                lbl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_loc_key(node)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; isinstance(node, ExprInt):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                lbl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_loc_key(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_get_int())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; isinstance(node, LocKey):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                lbl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_key
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lbl &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; executed_lockey:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                executed_lockey&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(lbl)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# We then collect the non-executed blocks by comparing the executed ones&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# with the totality of the blocks in the IRCFG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lbl, irblock &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; viewitems(ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lbl &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; executed_lockey:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        unexecuted_lockey&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(lbl)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Once we have the locations of the blocks that haven&amp;rsquo;t been executed, we can do a variety of things.
We could simply mark the non-executed blocks in order to inspect the target function for further analysis.
Yuma Kurogome shows how to do this in his course by dynamically creating an IDC script based on the context retrieved in previous stages:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;to_idc&lt;/span&gt;(lockeys, asmcfg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    header &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#include &amp;lt;idc.idc&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;static main(){
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    footer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    body &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;op-color.idc&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;w&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lbl &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; lockeys:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        asmblk &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; asmcfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_key_to_block(lbl)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; asmblk:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; asmblk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                print(hex(l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;offset))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                body &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SetColor(0x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%08x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, CIC_ITEM, 0xc7c7ff);&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;(l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;offset)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(header&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;body&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;footer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;After applying this we can obtain the following results (function at 0x40A6A0):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/x-tunnel_ops_detect.png#center&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;This can help us to figure out the logic of the implementation of the subject opaque predicates. Once this is clear, we can then write a solution to patch the binary to obtain a more clear view of the function&amp;rsquo;s control flow to apply further analysis to it such as optimizations or data flow analysis after opaque predicates are removed.
I decided to write a solution to remove X-Tunnel&amp;rsquo;s opaque predicates by using radare2 via its r2pipe Python binding:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove_xtunnel_op&lt;/span&gt;(lockeys, asmcfg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Opening File in r2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r2pipe&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./x-tunnel.bin&amp;#34;&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-w&amp;#34;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# applying reference analysis&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;aar&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# iterating for each block label&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lbl &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; lockeys:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# retrieving block from label&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        asmblk &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; asmcfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_key_to_block(lbl)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; asmblk:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; asmblk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# seeking to address of instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; hex(l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;offset))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# checking if there is any xrefs to&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# current instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                xref &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmdj(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;axtj&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;  xref:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# retrieving the reference source address&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    xref_from &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xref[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;from&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# retrieving the opcode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    opcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xref[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;opcode&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# seeking to reference source address&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; hex(xref_from))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# changing opcode for nop if its a je or a non&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# conditional jump if its any other branch instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wao &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;nop&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;je&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; opcode &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;nocj&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# seek back to original block instrution&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; hex(l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;offset))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# patching instruction with a nop&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wao nop&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# seeking to previous instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;so -1&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# retrieving its opcode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                opcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmdj(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pdj 1&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;opcode&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# if its a jne, change it to its&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# non-conditional form&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;jne&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; opcode:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cmd(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wao nocj&amp;#34;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;The full script can be downloaded &lt;a href=&#34;https://github.com/ulexec/ulexec.github.io/raw/master/files/remove_xtunnel_ops.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After applying this script we can obtain results as follows (function at 0x40A6A0):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/x-tunnel_ops.png#center&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;This approach can work for deterministic opaque perdicates although it has the following limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Path exploration algorithm can be very slow.&lt;/li&gt;
&lt;li&gt;SMT solver may have difficulties to solve specific contraints such as cryptographic schemes or hashing algorithms.&lt;/li&gt;
&lt;li&gt;Possibility of Path Explosion if input-dependant loops or recursion are found among other &lt;a href=&#34;https://arxiv.org/pdf/1908.01549.pdf&#34;&gt;techniques&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are known attacks against Symbolic Execution Analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input Dependant loops.&lt;/li&gt;
&lt;li&gt;Range Dividers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another approach to detect opaque predicates: Abstract Interpretation (TODO. Some nice &lt;a href=&#34;https://www.msreverseengineering.com/blog/2018/2/26/concrete-and-abstract-interpretation-explained-through-chess&#34;&gt;reference&lt;/a&gt; by Rolf Rolles)&lt;/p&gt;
&lt;p&gt;In the following section we will cover an approach to detect Range Dividers and how we can circumvent them.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;range-dividers&#34;&gt;Range Dividers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.researchgate.net/publication/311491954_Code_obfuscation_against_symbolic_execution_attacks&#34;&gt;Range dividers&lt;/a&gt; are branch conditions that can be inserted at an arbitrary position inside a basic block, such that they divide the input range into multiple sets.&lt;/p&gt;
&lt;p&gt;A simple example to illustrate this technique can be shown below:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; ; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strlen&lt;/span&gt;(str); str&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; , i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; chr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; (chr) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (hash &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; chr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (hash &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; chr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// obfuscated version of case 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// obfuscated version of case 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;In contrast to opaque predicates, range divider predicates may have multiple branches, any of which could be true and false depending on program input. This will cause symbolic execution engines to explore all branches of a range divider.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Branch execution is dependant on an input value&lt;/li&gt;
&lt;li&gt;All predicate branches have the same semantic meaning&lt;/li&gt;
&lt;li&gt;Robust against Symbolic Execution/Abstract Interpretation&lt;/li&gt;
&lt;li&gt;Almost like a n-way Opaque Predicate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The eﬀectiveness of a range divider predicate against symbolic execution depends on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number of branches of the predicate&lt;/li&gt;
&lt;li&gt;The number of times the predicate is executed&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;circumvention-2&#34;&gt;Circumvention&lt;/h3&gt;
&lt;p&gt;An approach to identify Range Dividers is by Semtantic Equivalence Checking.
Semantic Equivalence is an apporach to identify if two given sets of instructions have the same behavior based on the following premise:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Same Code: Syntactically Equivalent&lt;/li&gt;
&lt;li&gt;Same Behavior: Semantically Equivalent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How it works:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perform Symbolic Execution per basic block on a given function.&lt;/li&gt;
&lt;li&gt;Check for basic blocks semantic and syntactic equivalence within a given function.&lt;/li&gt;
&lt;li&gt;Can be also seen as Semantic basic block diffing&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;practical-example-deobfuscating-asprox-range-dividers&#34;&gt;Practical Example. Deobfuscating Asprox Range Dividers&lt;/h4&gt;
&lt;p&gt;The binary file we are going to use for this example is the following:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Asprox: c56792bea8ac5fbf893ae3df1be0c3c878a615db6b24fd5253e5cbbc2e3e1dd3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
The first thing we have to do is to retrieve all blocks from the subject obfuscated function.
Then we should compare for syntactic and semantic equivalence every block in the funtion with one another.
We can do this as follows:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# enumerate all blogs in target function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    target_blocks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; cn, block &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(asmcfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        target_blocks&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(block)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# iterate over all blocks to select src block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; src_blk &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; target_blocks:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve src block label from src block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        src_ldl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src_blk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_loc_key
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# Skip a basic blocks containing only single instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(src_blk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; src_blk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dstflow():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# iterate through all blocks again&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# to select dst block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; dst_blk &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; target_blocks:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve dst block label from dst block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            dst_ldl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dst_blk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_loc_key
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# Skip a basic block containing only single instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(dst_blk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; dst_blk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dstflow():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# Skip if src and dst block are the same block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; src_ldl &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; dst_ldl:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# Skip if src and dst blocks have already been matched&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (src_ldl, dst_ldl) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; results&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys() &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    (dst_ldl, src_ldl) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; results&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# Check for syntax equivalence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            r_syntax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; syntax_compare(src_blk, dst_blk)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; r_syntax:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# If the syntax of two blocks is same, then the semantics of them is also same.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                r_semantic &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# Check for semantic equivalence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                r_semantic &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; semantic_compare(src_blk, dst_blk, ir_arch0, ir_arch1, asmcfg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# save results of syntax and semantic checks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            results[(src_ldl, dst_ldl)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [(r_syntax, r_semantic)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Syntactic equivalence is fairly straight forward, for this we don&amp;rsquo;t even need to lift the subject block into IR.
This is how it can be implemented:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;syntax_compare&lt;/span&gt;(blk0, blk1):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# if blocks do not contain the same&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# number of instructions return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(blk0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; len(blk1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# iterate through all instructions in blocks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; l0, l1 &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(blk0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines, blk1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# if intruction is a branch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; str(l0)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;J&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve instruction opcode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            instr0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(l0)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            instr1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(l1)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; instr0 &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; instr1:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# any other instruction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; str(l0) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; str(l1):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
On the other hand, for Semantic equivalence its slightly more complicated:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;semantic_compare&lt;/span&gt;(blk0, blk1, ir_arch0, ir_arch1, asmcfg, flag_cmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# create empty IR CFG for src block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    src_ircfg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IRCFG(&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, ir_arch0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# add src block to empty IR CFG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ir_arch0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_asmblock_to_ircfg(blk0, src_ircfg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NotImplementedError&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# create empty IR CFG for dst block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dst_ircfg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IRCFG(&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, ir_arch1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# add dst block to empty IR CFG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ir_arch1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_asmblock_to_ircfg(blk1, dst_ircfg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NotImplementedError&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Check if blocks were added to their IRCFG correctly&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(src_ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; len(dst_ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; src_lbl, dst_lbl &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(src_ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks, dst_ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve both src and dst blocks from their labels&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        src_irb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src_ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(src_lbl, &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dst_irb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dst_ircfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;blocks&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(dst_lbl, &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# symbolically execute them to evaluate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# semantic equivalence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; execute_symbolic_execution(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            src_irb, dst_irb,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ir_arch0, ir_arch1,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            src_ircfg, dst_ircfg,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            flag_cmp)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
We lift both of the ASMBlock into IR ones (IRBlock of AssignBlocks) and then we symbolically execute them.
In order to sucessfully symbolically execute both of them, some default setup for each IR block has to be done:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Initialize symbol context with register context&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, r &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(all_regs_ids):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        src_symbols[r] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; all_regs_ids_init[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dst_symbols[r] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; all_regs_ids_init[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Instantiate Symbolic Execution Engine for src block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    src_sb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SymbolicExecutionEngine(ir_arch0, src_symbols)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# for each IR instruction in src block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; assignblk &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; src_irb:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        skip_update &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve IR expression and operand in block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; dst, src &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; viewitems(assignblk):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# If operand involves EIP or ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; str(dst) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;EIP&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;IRDst&amp;#39;&lt;/span&gt;]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# skip symbolic execution&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                skip_update &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# otherwise symbolically execute IR expression&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; skip_update:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            src_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;eval_updt_assignblk(assignblk)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Instantiate Symbolic Execution Engine for dest block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dst_sb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SymbolicExecutionEngine(ir_arch1, dst_symbols)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve IR expression and operand in block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; assignblk &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; dst_irb:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        skip_update &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# If operand involves EIP or ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; dst, src &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; viewitems(assignblk):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; str(dst) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;EIP&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;IRDst&amp;#39;&lt;/span&gt;]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# skip symbolic execution&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                skip_update &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; skip_update:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# otherwise symbolically execute IR expression&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            dst_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;eval_updt_assignblk(assignblk)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# set stack top for each symbolic engine&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    src_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;del_mem_above_stack(ir_arch0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sp)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dst_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;del_mem_above_stack(ir_arch1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sp)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
As we can see we have to configure the symbols we desire to symbolize, create one symbolic instance per block, Symbolically execute block and set up the top of the stack of each symbolic engine.&lt;/p&gt;
&lt;p&gt;When this is done then we can start checking for semantic equivalence by evaluating each of the symbol&amp;rsquo;s contraints of each symbolically executed block:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;# Retrieve all memory accesses from src and dst symbolic engines&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    all_memory_ids &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [k &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; dst_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;symbols&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memory()] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; [k &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; src_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;symbols&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memory()]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# iterate through all register and memory symbols&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# from both symbolic engines&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; all_regs_ids &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; all_memory_ids:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# keep iterating if symbol is EIP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; str(k) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;EIP&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# keep iterating if symbol is eflags&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; flag_cmp &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; [zf, nf, pf, of, cf, af, df, tf]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# retrieve value of symbol from each symbolic engine&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        v0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;symbols[k]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        v1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dst_sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;symbols[k]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# keep iterating if symbol value is the same&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; v0 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; v1:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# instantiate z3 SAT solver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        solver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; z3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Solver()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# translate src symbol constraints to z3 readable form&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            z3_r_cond &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Translator&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;to_language(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;z3&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_expr(v0)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NotImplementedError&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# translate dst symbol constraints to z3 readable form&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            z3_l_cond &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Translator&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;to_language(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;z3&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_expr(v1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NotImplementedError&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# add equality condition to solver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        solver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(z3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Not(z3_r_cond &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; z3_l_cond))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# if condition was unsatisfiable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; solver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;check()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; z3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;unsat:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# IR expression were equivalent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# keep iterating&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
After this we will have a list of all function&amp;rsquo;s blocks evaluation with each other in terms of syntactic and semantic equivalence:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# save results of syntax and semantic checks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;results[(src_ldl, dst_ldl)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [(r_syntax, r_semantic)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Having this we can create a graph based on this relationship and utilize it to mark the equivalent blocks in a given subject function:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# create graph&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    G &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Graph()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# add nodes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    G&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_nodes_from(target_blocks)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# add edges based on syntax/semantic equivalence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; viewitems(results):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# if blocks have syntactic or semantic equivalence&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; v[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; v[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# add edge on block labels&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            G&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_edge(k[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], k[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    random_colors &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gen_random_color()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    body &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Iterate through the blocks which are equivalent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; n, conn_nodes &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(nx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connected_components(G)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(conn_nodes) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; conn_nodes:  &lt;span style=&#34;color:#75715e&#34;&gt;# node is asmblk&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# set the same color for equivalent nodes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isinstance(node, LocKey):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                asmblk &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; asmcfg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc_key_to_block(node)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; asmblk:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; asmblk&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        body &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SetColor(0x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%08x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, CIC_ITEM, 0x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;offset, random_colors[n])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    body &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SetColor(0x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%08x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, CIC_ITEM, 0x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;offset, random_colors[n])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    header &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#include &amp;lt;idc.idc&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;static main()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    footer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;eq-color.idc&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;w&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(header &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; body &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; footer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;The full script can be downloaded &lt;a href=&#34;https://github.com/ulexec/ulexec.github.io/raw/master/files/range_divider_detector.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After applying the previous script to a given obfuscated function (0x10009B82) and slightly refine the results, we can obtain the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/asprox_range_divider.png#center&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;After this is trivial to remove the range divider predicates from the subject function. All we need is to identify the initial conditional branch that diverges into each individual predicate and apply the correspondent chnages to it appropietly.
The following are the before and after effects:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/asprox_range_divider2.png#center&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;In the particular case of Asprox I found that it wasn&amp;rsquo;t implementing a high number of Range Divider predicates, usually two. Therefore it was trivial to clean the code after identifying them.
All needed to do was to either patch the intial conditional branch that diverges into each individual predicate so that it becomes unconditional or patch the conditional branch in a way so that it becomes NOPed.
We can apply either of these approaches accordingly to chose the predicate that will drive the control flow and remove the remaining ones.&lt;/p&gt;
&lt;p&gt;Is also important to emphasize that the Range Divider cleaning process may not be as trivial if higher numbers of predicates where encountered or if the structure of the predicates would make each predicate to overlap with one another. Also lets not forget that this approach is assuming that the correct comparison unit is a basic block, which is true for Asprox predicates but is not necessarily generic. For example Tigress obfuscator implements Range Divider predicates on a function granuality. Therefore, this approach wont work, but could be adapted to support Tigress predicates re-defining the granuality for comparison and equivalence computation.&lt;/p&gt;
&lt;p&gt;To finish this section on a high note, we can see that by marking blocks from a given function based on syntax and semantic equivalence can help us to indentify this obfuscation technique.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Dissecting the Internals of custom Linux Binary Packers</title>
      <link>https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/</link>
      <pubDate>Fri, 17 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/</guid>
      <description>Overview In this writeup we&amp;rsquo;re going to unpack a Tsunami malware sample packed with a modified version of UPX. Hashes of this specific sample are the following:
SHA256: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863 SHA1: 76584c9a22835353186e753903ee0a853663bd83 MD5: 171edd284f6a19c6ed3fe010b79c94af In VirusTotal the malware is identified as a Tsunami Variant for the most part:
Is common in Linux systems to encounter packed malware with UPX. I then tried to see if I could find the UPX magic in the file.</description>
      <content>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;In this writeup we&amp;rsquo;re going to unpack a Tsunami malware sample packed with a modified version of &lt;code&gt;UPX&lt;/code&gt;. Hashes of this specific sample are the following:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SHA256: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  SHA1: &lt;span style=&#34;color:#ae81ff&#34;&gt;76584&lt;/span&gt;c9a22835353186e753903ee0a853663bd83
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   MD5: &lt;span style=&#34;color:#ae81ff&#34;&gt;171&lt;/span&gt;edd284f6a19c6ed3fe010b79c94af&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
In VirusTotal the malware is identified as a Tsunami Variant for the most part:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/1.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Is common in Linux systems to encounter packed malware with UPX. I then tried to see if I could find the &lt;code&gt;UPX&lt;/code&gt; magic in the file.&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8da20&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; UPX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Searching &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; bytes from &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt; to &lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffffffffffff&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;58&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Searching &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; bytes in [&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc01000&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc8e1c2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hits: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8ddaa&lt;/span&gt; hit0_0 .&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;M{UPX&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;u&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;RBuvkk.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8da20&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; s hit0_0 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8dda8&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pd &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8dda8&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;81f&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;955505821&lt;/span&gt;   CMP ECX, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x21585055&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8dda8&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x21585055&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UPX!&amp;#34;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00c8dda8&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;This is quite interesting because if we try to use the automated unpacking feature of &lt;code&gt;UPX&lt;/code&gt; we get an error:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;upx &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;d f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       Ultimate Packer &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; eXecutables
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#a6e22e&#34;&gt;Copyright&lt;/span&gt; (C) &lt;span style=&#34;color:#ae81ff&#34;&gt;1996&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2017&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;UPX &lt;span style=&#34;color:#ae81ff&#34;&gt;3.94&lt;/span&gt;        Markus Oberhumer, Laszlo Molnar &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; John Reiser   May &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;th &lt;span style=&#34;color:#ae81ff&#34;&gt;2017&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        File size         Ratio      Format      Name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;--------------------&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;------&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;-----------&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;-----------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;upx: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863: 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NotPackedException: not packed by UPX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Unpacked &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; files.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Threfore, we may be dealing with a custom packer based on a modified version of &lt;code&gt;UPX&lt;/code&gt;.
We will statically analyse the sample first, then we will continue our analysis with some dynamic analysis. At the end a brief summary of the sample will be discussed. Let&amp;rsquo;s start with static analysis.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;static-analysis&#34;&gt;Static Analysis&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;If we open the binary with &lt;code&gt;IDA PRO&lt;/code&gt; we can confirm that the sample is indeed packed:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/2.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/3.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;There are only 3 identifiable functions. Second and third functions seem straight forward. One allocates a &lt;code&gt;RWX&lt;/code&gt; page sized chunk, and the latter executes a write syscall and then exits.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/5.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/4.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The entry point of the application looks certainly more messier, and by first glance we can assume that it will have a decryptor/decoder functionality.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/6.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The first thing that the entrypoint does is calling &lt;code&gt;0x00C8DC28&lt;/code&gt;, which itself redirects execution to &lt;code&gt;allocate_rwx_page&lt;/code&gt; and stores the return address (&lt;code&gt;start+5&lt;/code&gt;) in ebp.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/7.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/8.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Note the stub of data on &lt;code&gt;0x00C8DC31&lt;/code&gt;, we will come back to it later.
Execution then falls into &lt;code&gt;allocate_rwx_page&lt;/code&gt; function, which as said before just allocates a memory page with &lt;code&gt;RXW&lt;/code&gt; permissions. This buffer will be allocated at &lt;code&gt;0x00C8F000&lt;/code&gt;. If the allocation fails, then execution will branch into the &lt;code&gt;write_message_and_exit&lt;/code&gt; funtion, in which the string &lt;code&gt;&#39;nandemo wa shiranai wa yo,&#39;&lt;/code&gt; gets printed to &lt;code&gt;stderr&lt;/code&gt;. On the other hand, if allocation of RWX chunk is sucessfull, execution will pivot back to &lt;code&gt;start+5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After allocating RWX memory, the malware will then proceed to copy and decode a given stub inside it. After a while analysing the code, I got to the conclusion that function &lt;code&gt;start+5&lt;/code&gt; (entrypoint+5) is the routine the malware uses to decode and copy packer stub. At this point I coudn&amp;rsquo;t do much progress just by static analysis. Therefore, I fired up the debugger ready to do some dynamic analysis.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;dynamic-analysis&#34;&gt;Dynamic Analysis&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Now that we have identified what routine the malware uses to decode and copy packer stub, It will be straight forward to trace the malware&amp;rsquo;s first stage, that is to decode some stub inside the RWX chunk by decoding the data block previosly shown. We will try to follow along execution flow until the destination chunk (chunk &lt;code&gt;0x00c8f000&lt;/code&gt;) of the decoded stub to remain with our analysis. One way this could be achieved would be by setting a hardware breakpoint on execution at the &lt;code&gt;RXW&lt;/code&gt; chunk. However, we want to find the cleanest possible way to withness the execution transition into the chunk in order to not overlook details about the first malware&amp;rsquo;s pivoting endeavour.&lt;/p&gt;
&lt;p&gt;On the entrypoint routine, after the function &lt;code&gt;pivot_to_allocate_rwx_pg&lt;/code&gt; we can clearly see that the register context is being saved with a &lt;code&gt;pusha&lt;/code&gt; instruction. Furthermore, two pointers are loaded into the &lt;code&gt;esi&lt;/code&gt; and &lt;code&gt;edi&lt;/code&gt; registers. Those pointers are the stub source address to be decoded, and the destination buffer address to transfer the decoded stub.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/10.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Further down &lt;code&gt;start&lt;/code&gt; we can see the set of instructions in charge of copying data from stub to the destination buffer:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/15.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Nevertheless, There are specific bytes that get processed differently. Some of the stub bytes have a many to one relationship with decoded bytes, so that multiple decoded bytes get derived from a single stub byte. Based on this we can assume that the decoding algorithm must be some sort of deflate implementation.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/16.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;We can see that decoding will stop when second argument &lt;code&gt;stub_size&lt;/code&gt; + first argument &lt;code&gt;stub_base&lt;/code&gt; == current stub pointer at &lt;code&gt;esi&lt;/code&gt;. If this condition is true, the function simply returns.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/11.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;If we put a breakpoint on this &lt;code&gt;retn&lt;/code&gt; instruction and then resume the application we will get control of execution back when decoding is over.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/12.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Upon decoding finalization, decoding routine does not pivot directly to the RWX chunk at &lt;code&gt;0x00c8f000&lt;/code&gt;, but it returns first to &lt;code&gt;allocate_rwx_page+49&lt;/code&gt; to then unwind the stack and return to the RWX chunk.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/13.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;When execution reaches the &lt;code&gt;0x00C8F000&lt;/code&gt; chunk, we see the following routine:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/14.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The main purpose of this routine is to retrieve the &lt;code&gt;ELF Auxiliar vector&lt;/code&gt; from the stack and copy it into a local stack buffer. The retrieved struture of the Auxiliar vector looks as follows:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/17.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Once Auxiliar vector is retrived from stack then &lt;code&gt;call_read_link&lt;/code&gt; function gets called. This function looks as follows:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/18.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;In this function a series of statistics are retrieved from the current file such as the location of the embedded &lt;code&gt;Elf&lt;/code&gt; file in the first &lt;code&gt;PT_LOAD&lt;/code&gt; segment along with 2 more flags used for decoding. Furthermore, the address of the page-aligned end of the first &lt;code&gt;PT_LOAD&lt;/code&gt; segment is computed and a stack buffer is reserved in order to store decoded stub. After collecting these fields this function proceeds with &lt;code&gt;stage1&lt;/code&gt; of the decoding process and calls &lt;code&gt;init_decoding_stage&lt;/code&gt; function. This function looks as follows:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/19.jpg/#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;This routine is the entry point of what would be the stub decoding stage. the first part of this function calls &lt;code&gt;set_for_decoding&lt;/code&gt; function . This function gets called with the previously reserved stack buffer dedicated for storing decoded stub and two stub flags as arguments. Function &lt;code&gt;set_for_decoding&lt;/code&gt; looks as follows:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/20.jpg/#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Based on the flags passed to this function it will copy different values of the stub into a prepared buffer. We see that when stub buffer is ready the decoding function will get called (&lt;code&gt;start+5&lt;/code&gt;).
If we step into the decoding function we see that the values in &lt;code&gt;esi&lt;/code&gt; and &lt;code&gt;edi&lt;/code&gt; registers have changed in comparison with the earlier call to this function:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/21.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;If we continue until our previously saved breakpoint at &lt;code&gt;retn&lt;/code&gt; instruction we can identify an ELF header and a program header table within the destination buffer after decoding.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/22.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Once the ELF header and the Program header table of embedded file get decded, execution continues after the call to &lt;code&gt;set_for_decoding&lt;/code&gt; in the &lt;code&gt;init_decoding_stage&lt;/code&gt; function.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/23.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Now that the program header table of embedded executable is decoded the malware is able to parse some of its fields in order to figure out where to load in memory its correspondent segments for sucesfull unpacking. Furthermore, the malware updates it&amp;rsquo;s own &lt;code&gt;Auxiliar vector&lt;/code&gt; with statistics of the embedded file in order to reuse that same structure on the loading process of the embedded executable. Malware updates &lt;code&gt;AT_PHNUM&lt;/code&gt; , &lt;code&gt;AT_PHENT&lt;/code&gt; and &lt;code&gt;AT_PHDR&lt;/code&gt; fields of the &lt;code&gt;Auxiliar vector&lt;/code&gt; at this point but it will be updating more fields in the remaining decoding process. After updating the Auxiliar vector, malware calls &lt;code&gt;ux_exec&lt;/code&gt; function. This function is sort of an &lt;code&gt;execve&lt;/code&gt; userland implementation which is in charge of loading the embedded executable segments and pivot execution to the &lt;code&gt;OEP&lt;/code&gt; without interaction with the kernel. This function looks as follows:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/24.jpg/#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;Ux_exec&lt;/code&gt; function first scans all segments in decoded proram header table in order to find the &lt;code&gt;CODE&lt;/code&gt; segment( the first &lt;code&gt;PT_LOAD&lt;/code&gt; segment). Once &lt;code&gt;CODE&lt;/code&gt; segment has been found, a mmap system call gets invoked via &lt;code&gt;mmap_gate&lt;/code&gt; function, passing the segment&amp;rsquo;s &lt;code&gt;p_vaddr&lt;/code&gt; value along with its page aligned &lt;code&gt;p_memsz&lt;/code&gt; field as arguments. Upon&lt;code&gt;CODE&lt;/code&gt; segment allocation execution flow enters a loop in which every &lt;code&gt;PT_LOAD&lt;/code&gt; segments existent in the program header table gets scanned to be decoded. For every &lt;code&gt;PT_LOAD&lt;/code&gt; segment that is not the &lt;code&gt;CODE&lt;/code&gt; segment, this loop will call &lt;code&gt;mmap_gate&lt;/code&gt; function again in order to map the segment.&lt;/p&gt;
&lt;p&gt;For every existent &lt;code&gt;PT_LOAD&lt;/code&gt; segment, a call to &lt;code&gt;set_for_decoding&lt;/code&gt; is made. We already cover this function previously. Therefore, I will try to avoid redundancy and I will not explain this routine again. After the &lt;code&gt;set_fo_decoding&lt;/code&gt; call, our breakpoint in the decoding routine gets triggered once again and this time seems to be decoding into the base address of the embedded binary:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/25.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Once our &lt;code&gt;retn&lt;/code&gt; breakpoint gets triggered, the destination buffer seems partially decoded:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/26.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The segments get decoded in rounds, the following screenshot is the second round of the &lt;code&gt;CODE&lt;/code&gt; segment&amp;rsquo;s decoding, so we can have an idea how the decoding looks like:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/27.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/28.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Upon segment decoding completion, a &lt;code&gt;mprotect&lt;/code&gt; system call is invoked in order to enforce the original segment&amp;rsquo;s attributes. This is due to the fact that when container chunk was allocated by &lt;code&gt;mmap&lt;/code&gt; syscall it must had wrtie permissions in order to write the decoded stub into the chunk.
The code also checks if current segment base + size exceeds the end of the &lt;code&gt;DATA&lt;/code&gt; segment. If that is the case, a chunk will be mmapped after the &lt;code&gt;DATA&lt;/code&gt; segment, and a &lt;code&gt;brk&lt;/code&gt; syscall will be invoked. The &lt;code&gt;brk&lt;/code&gt; system call will initialise a series of pointers that would make the mmap chunk at the end of the data segment being initialised as the &lt;code&gt;HEAP&lt;/code&gt; segment. &lt;code&gt;brk&lt;/code&gt; systemcall does not actually allocate any memory, just initialises &lt;code&gt;program break&lt;/code&gt;, &lt;code&gt;start_brk&lt;/code&gt; and &lt;code&gt;end_data&lt;/code&gt;. However, at this very point there is no &lt;code&gt;HEAP&lt;/code&gt; segment since initially program break = start_brk. Nevertheless, in future malloc calls the program break address will increase and the &lt;code&gt;HEAP&lt;/code&gt; segment (space between start_brk and program break) will fall within the mmapped chunk at the end of the &lt;code&gt;DATA&lt;/code&gt; segment.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/29.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;After &lt;code&gt;ux_exec&lt;/code&gt; function is done loading all segments of embedded executable, control flow returns back to &lt;code&gt;init_decoding_stage&lt;/code&gt; after the call to &lt;code&gt;ux_exec&lt;/code&gt;. There is just one more thing remaining to do before pivoting to OEP, check for a &lt;code&gt;PT_INTERP&lt;/code&gt; segment. If this segment exists then the embedded executable is a dynamically linked executable, and the &lt;code&gt;RTLD&lt;/code&gt; must be mapped. The &lt;code&gt;RTLD&lt;/code&gt; will be opened, read and then a call to &lt;code&gt;ux_exec&lt;/code&gt; will be done again in order to map the shared object&amp;rsquo;s segments into the right location within the virtual address space.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/30.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;So far we covered all steps the packer does for decoding and loading the embedded executable. A brief overview of the packer&amp;rsquo;s functionality is the following:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/prev.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;At this point we know that the file is fully loaded into its respective virtual address. If we check the mappings we see the following:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://ulexec.github.io/Tsunami/31.png#center&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;In order to retrieve the embedded executable we can use the following IDA script to dump the embedded file succesfully:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; struct
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Elf32Phdr&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, bytes):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_type,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_offset,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_vaddr,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_paddr,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_filesz,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_memsz,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_flags,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_align,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; struct&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;unpack(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8I&amp;#34;&lt;/span&gt;, bytes[:&lt;span style=&#34;color:#ae81ff&#34;&gt;0x20&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ElfEhdr&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, bytes):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         (self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_type,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_machine,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_version,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_entry,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phoff,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shoff,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_flags,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_ehsize,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phentsize,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phnum,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shentsize,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shnum,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shstrndx) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; struct&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;unpack(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2H5I6H&amp;#34;&lt;/span&gt;, bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;52&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __str__(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; struct&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pack(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2H5I6H&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_type,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_machine,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_version,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_entry,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phoff,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shoff,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_flags,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_ehsize,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phentsize,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phnum,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shentsize,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shnum,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shstrndx) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dumpElf&lt;/span&gt;(image_base):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    file &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Users/n4x0r/Desktop/dumped.elf&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetManyBytes(image_base, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ehdr  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ElfEhdr(bytes) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    phoff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ehdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phoff
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    phnum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ehdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_phnum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    phdrtbl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes[phoff:]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ehdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shoff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ehdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shnum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ehdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;e_shstrndx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(phnum):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        phdr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Elf32Phdr(phdrtbl[:&lt;span style=&#34;color:#ae81ff&#34;&gt;0x20&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; phdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_type &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            poffs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; phdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_offset
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            psize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; phdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_filesz
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            paddr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; phdr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;p_vaddr
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            phdata &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetManyBytes(paddr, psize)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            file&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;seek(poffs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            file&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(phdata)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        phdrtbl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; phdrtbl[&lt;span style=&#34;color:#ae81ff&#34;&gt;0x20&lt;/span&gt;:]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    file&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;seek(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    file&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(bytes[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; str(ehdr))   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    file&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[+] Elf Dumped&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Once on disk we see that the dumped file is a 1.3M statically linked binary:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ELF Header:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Magic:   &lt;span style=&#34;color:#ae81ff&#34;&gt;7f&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;c &lt;span style=&#34;color:#ae81ff&#34;&gt;46&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;03&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Class:                             ELF32
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Data:                              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;s complement, little endian
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Version:                           &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (current)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  OS&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;ABI:                            UNIX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; GNU
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ABI Version:                       &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Type:                              &lt;span style=&#34;color:#a6e22e&#34;&gt;EXEC&lt;/span&gt; (Executable file)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Machine:                           Intel &lt;span style=&#34;color:#ae81ff&#34;&gt;80386&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Version:                           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Entry point address:               &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8048d86&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Start of program headers:          &lt;span style=&#34;color:#ae81ff&#34;&gt;52&lt;/span&gt; (bytes into file)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Start of section headers:          &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (bytes into file)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Flags:                             &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Size of this header:               &lt;span style=&#34;color:#ae81ff&#34;&gt;52&lt;/span&gt; (bytes)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Size of program headers:           &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; (bytes)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Number of program headers:         &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Size of section headers:           &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; (bytes)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Number of section headers:         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Section header string table index: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Program Headers:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LOAD           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x000000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08048000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08048000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14ba2e&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14ba2e&lt;/span&gt; R E &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LOAD           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14bea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08194ea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08194ea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x02374&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x06460&lt;/span&gt; RW  &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NOTE           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0000f4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x080480f4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x080480f4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00044&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00044&lt;/span&gt; R   &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  TLS            &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14bea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08194ea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08194ea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00014&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00038&lt;/span&gt; R   &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  GNU_STACK      &lt;span style=&#34;color:#ae81ff&#34;&gt;0x000000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000&lt;/span&gt; RW  &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  GNU_RELRO      &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14bea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08194ea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x08194ea4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0115c&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0115c&lt;/span&gt; R   &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;Tracing until decoding of Elf header and program header table.&lt;/li&gt;
&lt;li&gt;Set hardware breapoint on execution at entry-point address in the Elf header.&lt;/li&gt;
&lt;li&gt;Profit.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;In the next write up I will cover the analysis process of the unpacked file.
Thanks for reading and I hope you learned something useful from this post!.&lt;/p&gt;
&lt;p&gt;n4x0r.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
