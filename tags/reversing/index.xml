<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>reversing on ulexec.github.io</title>
    <link>https://ulexec.github.io/tags/reversing/</link>
    <description>Recent content in reversing on ulexec.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 08 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ulexec.github.io/tags/reversing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SHELF Loading</title>
      <link>https://ulexec.github.io/post/2021-04-08-shelfloading/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2021-04-08-shelfloading/</guid>
      <description>SHELF Loading is a new type of ELF binary reflective loading that my colleague @Anonymous_ and I first documented on April 21st 2021. This new ELF reflective loading methodology enables the capability to generate compiler-based artifacts with properties that resemble those of shellcode. These compiler-based artifacts are ultimately a Hybrid ELF file between conventional static and PIE binaries. Had the pleasure to publish this research at Tmp0ut, a Linux VX zine.</description>
    </item>
    
    <item>
      <title>Tales Of Binary Deobfuscation</title>
      <link>https://ulexec.github.io/post/2020-03-03-deobfuscation_1/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2020-03-03-deobfuscation_1/</guid>
      <description>This article is going to serve as my personal reference on this topic. Since I&amp;rsquo;ve always wanted to write about it and just finished Yuma Kurogome&amp;rsquo;s course on Advance Binary Deobfuscation, I thought it would be a good time to write notes regarding what I learned in this course with a fresh state of mind on the subject matter for future reference.
Introduction There are close to 31 known code transformations.</description>
    </item>
    
    <item>
      <title>Dissecting the Internals of custom Linux Binary Packers</title>
      <link>https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/</link>
      <pubDate>Fri, 17 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/</guid>
      <description>Overview In this writeup we&amp;rsquo;re going to unpack a Tsunami malware sample packed with a modified version of UPX. Hashes of this specific sample are the following:
SHA256: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863 SHA1: 76584c9a22835353186e753903ee0a853663bd83 MD5: 171edd284f6a19c6ed3fe010b79c94af In VirusTotal the malware is identified as a Tsunami Variant for the most part:
Is common in Linux systems to encounter packed malware with UPX. I then tried to see if I could find the UPX magic in the file.</description>
    </item>
    
    <item>
      <title>Hitcon2017CTF - 家徒四壁~Everlasting Imaginative Void~</title>
      <link>https://ulexec.github.io/post/2017-11-06-hitconctf2017-everlasting-imaginative-void/</link>
      <pubDate>Mon, 06 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2017-11-06-hitconctf2017-everlasting-imaginative-void/</guid>
      <description>Everlasting Imaginative void was a Hitcon2017&amp;rsquo;s reversing challenge worthing 300 points. The challenge description was the following:
Astonishingly impoverished elf
Not much information. Executing a file command, we get the following information:
n4x0r@pwn1e~$ file void-1b63cbab5d58da4294c2f97d6b60f568 void-1b63cbab5d58da4294c2f97d6b60f568: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5f8a87150720003c217508ffd74883c715ffe7c3, stripped If we execute the file we see the following:
n4x0r@pwn1e~$ ./void-1b63cbab5d58da4294c2f97d6b60f568 blabla hitcon{blabla} Ok, Lets dig inside and see what we can find.</description>
    </item>
    
    <item>
      <title>CodeGateCTF - Angrybird</title>
      <link>https://ulexec.github.io/post/2017-02-11-codegatectf2017-angrybird/</link>
      <pubDate>Sat, 11 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2017-02-11-codegatectf2017-angrybird/</guid>
      <description>Angrybird was the first challenge that I solved on the 2017 CodeGate2017 CTF. There was no description for the challenge just a binary.
When we opened the binary with IDA, we can see the graph overview of the main function:
if we have a closer look at the call graph, every basic block is composed of a small check. if that check holds, then the flow of execution continues to the next block.</description>
    </item>
    
    <item>
      <title>AlexCTF - PackedMovement</title>
      <link>https://ulexec.github.io/post/2017-02-10-alexctf-packedmovement/</link>
      <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2017-02-10-alexctf-packedmovement/</guid>
      <description>PackedMovement was the last Reverse Engineering challenge on AlexCTF 2017. The puntuation of this challnege was of 350 points.
The only hint given to this challenge was its name. You will see why later on in this writeup.
The retrieved binary is called move. if we run the file command over it we find the following:
move: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, stripped Even more interesting is when we see the binaries segments with readelf -l move</description>
    </item>
    
    <item>
      <title>SharifCTF7 - Nanomites</title>
      <link>https://ulexec.github.io/post/2016-12-19-sharifctf2016-nanomites/</link>
      <pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ulexec.github.io/post/2016-12-19-sharifctf2016-nanomites/</guid>
      <description>Nanomites was a Reverse engineering challenge of 300 point in SharifCTF7. The specification of this problem was the following:
Analyze the given file. Find the C&amp;amp;C IP address and the data sent to it in plain text. Flag = SharifCTF{md5(strcat(IP, Data))}_ For the ones that coud not attend the competition, You can download the challenge from here.
After running the command file against the binary, I got the following output:</description>
    </item>
    
  </channel>
</rss>
