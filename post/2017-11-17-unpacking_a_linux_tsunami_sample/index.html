<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Dissecting the Internals of custom Linux Binary Packers :: ulexec.github.io</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Overview In this writeup we&amp;rsquo;re going to unpack a Tsunami malware sample packed with a modified version of UPX. Hashes of this specific sample are the following:
SHA256: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863 SHA1: 76584c9a22835353186e753903ee0a853663bd83 MD5: 171edd284f6a19c6ed3fe010b79c94af In VirusTotal the malware is identified as a Tsunami Variant for the most part:
Is common in Linux systems to encounter packed malware with UPX. I then tried to see if I could find the UPX magic in the file." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/" />






  
  
  
  
  
  <link rel="stylesheet" href="https://ulexec.github.io/styles.css">







  <link rel="shortcut icon" href="https://ulexec.github.io/img/theme-colors/blue.png">
  <link rel="apple-touch-icon" href="https://ulexec.github.io/img/theme-colors/blue.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Dissecting the Internals of custom Linux Binary Packers">
<meta property="og:description" content="Overview In this writeup we&amp;rsquo;re going to unpack a Tsunami malware sample packed with a modified version of UPX. Hashes of this specific sample are the following:
SHA256: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863 SHA1: 76584c9a22835353186e753903ee0a853663bd83 MD5: 171edd284f6a19c6ed3fe010b79c94af In VirusTotal the malware is identified as a Tsunami Variant for the most part:
Is common in Linux systems to encounter packed malware with UPX. I then tried to see if I could find the UPX magic in the file." />
<meta property="og:url" content="https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/" />
<meta property="og:site_name" content="ulexec.github.io" />

  
    <meta property="og:image" content="https://ulexec.github.io/img/favicon/blue.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="writeup" />


  <meta property="article:published_time" content="2017-11-17 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/post/">
  <div class="logo">
    ulexec.github.io
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;â–¾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/post/">Archives</a></li>
        
      
        
          <li><a href="/publications/">Publications</a></li>
        
      
        
          <li><a href="/projects/">Projects</a></li>
        
      
        
          <li><a href="/bugs/">Bugs</a></li>
        
      
        
          <li><a href="/about/">About</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/post/" >Archives</a></li>
        
      
        
          <li><a href="/publications/" >Publications</a></li>
        
      
        
          <li><a href="/projects/" >Projects</a></li>
        
      
        
          <li><a href="/bugs/" >Bugs</a></li>
        
      
        
          <li><a href="/about/" >About</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://ulexec.github.io/post/2017-11-17-unpacking_a_linux_tsunami_sample/">Dissecting the Internals of custom Linux Binary Packers</a>
  </h1>
  <div class="post-meta"><time class="post-date">2017-11-17</time><span class="post-author">ulexec</span></div>

  
    <span class="post-tags">
      
      #<a href="https://ulexec.github.io/tags/reversing/">reversing</a>&nbsp;
      
      #<a href="https://ulexec.github.io/tags/malware/">malware</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Table of Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#static-analysis">Static Analysis</a></li>
    <li><a href="#dynamic-analysis">Dynamic Analysis</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="overview">Overview<a href="#overview" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>In this writeup we&rsquo;re going to unpack a Tsunami malware sample packed with a modified version of <code>UPX</code>. Hashes of this specific sample are the following:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SHA256: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863
</span></span><span style="display:flex;"><span>  SHA1: <span style="color:#ae81ff">76584</span>c9a22835353186e753903ee0a853663bd83
</span></span><span style="display:flex;"><span>   MD5: <span style="color:#ae81ff">171</span>edd284f6a19c6ed3fe010b79c94af</span></span></code></pre></div>
In VirusTotal the malware is identified as a Tsunami Variant for the most part:</p>
<p><img src="/Tsunami/1.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Is common in Linux systems to encounter packed malware with UPX. I then tried to see if I could find the <code>UPX</code> magic in the file.</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#ae81ff">0x00c8da20</span>]<span style="color:#f92672">&gt;</span> <span style="color:#f92672">/</span> UPX
</span></span><span style="display:flex;"><span>Searching <span style="color:#ae81ff">3</span> bytes from <span style="color:#ae81ff">0x00000000</span> to <span style="color:#ae81ff">0xffffffffffffffff</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">55</span> <span style="color:#ae81ff">50</span> <span style="color:#ae81ff">58</span> 
</span></span><span style="display:flex;"><span>Searching <span style="color:#ae81ff">3</span> bytes in [<span style="color:#ae81ff">0xc01000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0xc8e1c2</span>]
</span></span><span style="display:flex;"><span>hits: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0x00c8ddaa</span> hit0_0 .<span style="color:#960050;background-color:#1e0010">@</span>M{UPX<span style="color:#f92672">!</span>u<span style="color:#f92672">&gt;</span>RBuvkk.
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">0x00c8da20</span>]<span style="color:#f92672">&gt;</span> s hit0_0 <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">0x00c8dda8</span>]<span style="color:#f92672">&gt;</span> pd <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0x00c8dda8</span>  <span style="color:#f92672">~</span>   <span style="color:#ae81ff">81f</span><span style="color:#ae81ff">955505821</span>   CMP ECX, <span style="color:#ae81ff">0x21585055</span>
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">0x00c8dda8</span>]<span style="color:#f92672">&gt;</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">0x21585055</span><span style="color:#f92672">~</span>[<span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;UPX!&#34;</span> 
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">0x00c8dda8</span>]<span style="color:#f92672">&gt;</span> 
</span></span></code></pre></div>This is quite interesting because if we try to use the automated unpacking feature of <code>UPX</code> we get an error:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>upx <span style="color:#f92672">-</span>d f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863
</span></span><span style="display:flex;"><span>                       Ultimate Packer <span style="color:#66d9ef">for</span> eXecutables
</span></span><span style="display:flex;"><span>                          <span style="color:#a6e22e">Copyright</span> (C) <span style="color:#ae81ff">1996</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2017</span>
</span></span><span style="display:flex;"><span>UPX <span style="color:#ae81ff">3.94</span>        Markus Oberhumer, Laszlo Molnar <span style="color:#f92672">&amp;</span> John Reiser   May <span style="color:#ae81ff">12</span>th <span style="color:#ae81ff">2017</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        File size         Ratio      Format      Name
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">--------------------</span>   <span style="color:#f92672">------</span>   <span style="color:#f92672">-----------</span>   <span style="color:#f92672">-----------</span>
</span></span><span style="display:flex;"><span>upx: f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863: 
</span></span><span style="display:flex;"><span>NotPackedException: not packed by UPX
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Unpacked <span style="color:#ae81ff">0</span> files.</span></span></code></pre></div>
Threfore, we may be dealing with a custom packer based on a modified version of <code>UPX</code>.
We will statically analyse the sample first, then we will continue our analysis with some dynamic analysis. At the end a brief summary of the sample will be discussed. Let&rsquo;s start with static analysis.</p>
<!-- raw HTML omitted -->
<h2 id="static-analysis">Static Analysis<a href="#static-analysis" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<!-- raw HTML omitted -->
<p>If we open the binary with <code>IDA PRO</code> we can confirm that the sample is indeed packed:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/2.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/3.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>There are only 3 identifiable functions. Second and third functions seem straight forward. One allocates a <code>RWX</code> page sized chunk, and the latter executes a write syscall and then exits.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/5.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/4.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>The entry point of the application looks certainly more messier, and by first glance we can assume that it will have a decryptor/decoder functionality.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/6.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>The first thing that the entrypoint does is calling <code>0x00C8DC28</code>, which itself redirects execution to <code>allocate_rwx_page</code> and stores the return address (<code>start+5</code>) in ebp.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/7.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/8.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Note the stub of data on <code>0x00C8DC31</code>, we will come back to it later.
Execution then falls into <code>allocate_rwx_page</code> function, which as said before just allocates a memory page with <code>RXW</code> permissions. This buffer will be allocated at <code>0x00C8F000</code>. If the allocation fails, then execution will branch into the <code>write_message_and_exit</code> funtion, in which the string <code>'nandemo wa shiranai wa yo,'</code> gets printed to <code>stderr</code>. On the other hand, if allocation of RWX chunk is sucessfull, execution will pivot back to <code>start+5</code>.</p>
<p>After allocating RWX memory, the malware will then proceed to copy and decode a given stub inside it. After a while analysing the code, I got to the conclusion that function <code>start+5</code> (entrypoint+5) is the routine the malware uses to decode and copy packer stub. At this point I coudn&rsquo;t do much progress just by static analysis. Therefore, I fired up the debugger ready to do some dynamic analysis.</p>
<!-- raw HTML omitted -->
<h2 id="dynamic-analysis">Dynamic Analysis<a href="#dynamic-analysis" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<!-- raw HTML omitted -->
<p>Now that we have identified what routine the malware uses to decode and copy packer stub, It will be straight forward to trace the malware&rsquo;s first stage, that is to decode some stub inside the RWX chunk by decoding the data block previosly shown. We will try to follow along execution flow until the destination chunk (chunk <code>0x00c8f000</code>) of the decoded stub to remain with our analysis. One way this could be achieved would be by setting a hardware breakpoint on execution at the <code>RXW</code> chunk. However, we want to find the cleanest possible way to withness the execution transition into the chunk in order to not overlook details about the first malware&rsquo;s pivoting endeavour.</p>
<p>On the entrypoint routine, after the function <code>pivot_to_allocate_rwx_pg</code> we can clearly see that the register context is being saved with a <code>pusha</code> instruction. Furthermore, two pointers are loaded into the <code>esi</code> and <code>edi</code> registers. Those pointers are the stub source address to be decoded, and the destination buffer address to transfer the decoded stub.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/10.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Further down <code>start</code> we can see the set of instructions in charge of copying data from stub to the destination buffer:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/15.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Nevertheless, There are specific bytes that get processed differently. Some of the stub bytes have a many to one relationship with decoded bytes, so that multiple decoded bytes get derived from a single stub byte. Based on this we can assume that the decoding algorithm must be some sort of deflate implementation.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/16.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>We can see that decoding will stop when second argument <code>stub_size</code> + first argument <code>stub_base</code> == current stub pointer at <code>esi</code>. If this condition is true, the function simply returns.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/11.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>If we put a breakpoint on this <code>retn</code> instruction and then resume the application we will get control of execution back when decoding is over.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/12.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Upon decoding finalization, decoding routine does not pivot directly to the RWX chunk at <code>0x00c8f000</code>, but it returns first to <code>allocate_rwx_page+49</code> to then unwind the stack and return to the RWX chunk.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/13.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>When execution reaches the <code>0x00C8F000</code> chunk, we see the following routine:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/14.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>The main purpose of this routine is to retrieve the <code>ELF Auxiliar vector</code> from the stack and copy it into a local stack buffer. The retrieved struture of the Auxiliar vector looks as follows:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/17.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Once Auxiliar vector is retrived from stack then <code>call_read_link</code> function gets called. This function looks as follows:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/18.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>In this function a series of statistics are retrieved from the current file such as the location of the embedded <code>Elf</code> file in the first <code>PT_LOAD</code> segment along with 2 more flags used for decoding. Furthermore, the address of the page-aligned end of the first <code>PT_LOAD</code> segment is computed and a stack buffer is reserved in order to store decoded stub. After collecting these fields this function proceeds with <code>stage1</code> of the decoding process and calls <code>init_decoding_stage</code> function. This function looks as follows:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/19.jpg/#center" alt=""></p>
<!-- raw HTML omitted -->
<p>This routine is the entry point of what would be the stub decoding stage. the first part of this function calls <code>set_for_decoding</code> function . This function gets called with the previously reserved stack buffer dedicated for storing decoded stub and two stub flags as arguments. Function <code>set_for_decoding</code> looks as follows:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/20.jpg/#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Based on the flags passed to this function it will copy different values of the stub into a prepared buffer. We see that when stub buffer is ready the decoding function will get called (<code>start+5</code>).
If we step into the decoding function we see that the values in <code>esi</code> and <code>edi</code> registers have changed in comparison with the earlier call to this function:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/21.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>If we continue until our previously saved breakpoint at <code>retn</code> instruction we can identify an ELF header and a program header table within the destination buffer after decoding.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/22.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Once the ELF header and the Program header table of embedded file get decded, execution continues after the call to <code>set_for_decoding</code> in the <code>init_decoding_stage</code> function.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/23.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Now that the program header table of embedded executable is decoded the malware is able to parse some of its fields in order to figure out where to load in memory its correspondent segments for sucesfull unpacking. Furthermore, the malware updates it&rsquo;s own <code>Auxiliar vector</code> with statistics of the embedded file in order to reuse that same structure on the loading process of the embedded executable. Malware updates <code>AT_PHNUM</code> , <code>AT_PHENT</code> and <code>AT_PHDR</code> fields of the <code>Auxiliar vector</code> at this point but it will be updating more fields in the remaining decoding process. After updating the Auxiliar vector, malware calls <code>ux_exec</code> function. This function is sort of an <code>execve</code> userland implementation which is in charge of loading the embedded executable segments and pivot execution to the <code>OEP</code> without interaction with the kernel. This function looks as follows:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/24.jpg/#center" alt=""></p>
<!-- raw HTML omitted -->
<p><code>Ux_exec</code> function first scans all segments in decoded proram header table in order to find the <code>CODE</code> segment( the first <code>PT_LOAD</code> segment). Once <code>CODE</code> segment has been found, a mmap system call gets invoked via <code>mmap_gate</code> function, passing the segment&rsquo;s <code>p_vaddr</code> value along with its page aligned <code>p_memsz</code> field as arguments. Upon<code>CODE</code> segment allocation execution flow enters a loop in which every <code>PT_LOAD</code> segments existent in the program header table gets scanned to be decoded. For every <code>PT_LOAD</code> segment that is not the <code>CODE</code> segment, this loop will call <code>mmap_gate</code> function again in order to map the segment.</p>
<p>For every existent <code>PT_LOAD</code> segment, a call to <code>set_for_decoding</code> is made. We already cover this function previously. Therefore, I will try to avoid redundancy and I will not explain this routine again. After the <code>set_fo_decoding</code> call, our breakpoint in the decoding routine gets triggered once again and this time seems to be decoding into the base address of the embedded binary:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/25.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Once our <code>retn</code> breakpoint gets triggered, the destination buffer seems partially decoded:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/26.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>The segments get decoded in rounds, the following screenshot is the second round of the <code>CODE</code> segment&rsquo;s decoding, so we can have an idea how the decoding looks like:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/27.png#center" alt=""></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><img src="/Tsunami/28.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>Upon segment decoding completion, a <code>mprotect</code> system call is invoked in order to enforce the original segment&rsquo;s attributes. This is due to the fact that when container chunk was allocated by <code>mmap</code> syscall it must had wrtie permissions in order to write the decoded stub into the chunk.
The code also checks if current segment base + size exceeds the end of the <code>DATA</code> segment. If that is the case, a chunk will be mmapped after the <code>DATA</code> segment, and a <code>brk</code> syscall will be invoked. The <code>brk</code> system call will initialise a series of pointers that would make the mmap chunk at the end of the data segment being initialised as the <code>HEAP</code> segment. <code>brk</code> systemcall does not actually allocate any memory, just initialises <code>program break</code>, <code>start_brk</code> and <code>end_data</code>. However, at this very point there is no <code>HEAP</code> segment since initially program break = start_brk. Nevertheless, in future malloc calls the program break address will increase and the <code>HEAP</code> segment (space between start_brk and program break) will fall within the mmapped chunk at the end of the <code>DATA</code> segment.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/29.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>After <code>ux_exec</code> function is done loading all segments of embedded executable, control flow returns back to <code>init_decoding_stage</code> after the call to <code>ux_exec</code>. There is just one more thing remaining to do before pivoting to OEP, check for a <code>PT_INTERP</code> segment. If this segment exists then the embedded executable is a dynamically linked executable, and the <code>RTLD</code> must be mapped. The <code>RTLD</code> will be opened, read and then a call to <code>ux_exec</code> will be done again in order to map the shared object&rsquo;s segments into the right location within the virtual address space.</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/30.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>So far we covered all steps the packer does for decoding and loading the embedded executable. A brief overview of the packer&rsquo;s functionality is the following:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/prev.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>At this point we know that the file is fully loaded into its respective virtual address. If we check the mappings we see the following:</p>
<!-- raw HTML omitted -->
<p><img src="/Tsunami/31.png#center" alt=""></p>
<!-- raw HTML omitted -->
<p>In order to retrieve the embedded executable we can use the following IDA script to dump the embedded file succesfully:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Elf32Phdr</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, bytes):
</span></span><span style="display:flex;"><span>        (self<span style="color:#f92672">.</span>p_type,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_offset,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_vaddr,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_paddr,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_filesz,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_memsz,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_flags,
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p_align,
</span></span><span style="display:flex;"><span>        ) <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;8I&#34;</span>, bytes[:<span style="color:#ae81ff">0x20</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ElfEhdr</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, bytes):
</span></span><span style="display:flex;"><span>         (self<span style="color:#f92672">.</span>e_type,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_machine,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_version,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_entry,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_phoff,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shoff,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_flags,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_ehsize,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_phentsize,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_phnum,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shentsize,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shnum,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shstrndx) <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;2H5I6H&#34;</span>, bytes[<span style="color:#ae81ff">16</span>:<span style="color:#ae81ff">52</span>])
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __str__(self):
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;2H5I6H&#34;</span>,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_type,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_machine,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_version,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_entry,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_phoff,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shoff,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_flags,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_ehsize,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_phentsize,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_phnum,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shentsize,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shnum,
</span></span><span style="display:flex;"><span>         self<span style="color:#f92672">.</span>e_shstrndx) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dumpElf</span>(image_base):
</span></span><span style="display:flex;"><span>    file <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/Users/n4x0r/Desktop/dumped.elf&#34;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>)
</span></span><span style="display:flex;"><span>    bytes <span style="color:#f92672">=</span> GetManyBytes(image_base, <span style="color:#ae81ff">0x100</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ehdr  <span style="color:#f92672">=</span> ElfEhdr(bytes) 
</span></span><span style="display:flex;"><span>    phoff <span style="color:#f92672">=</span> ehdr<span style="color:#f92672">.</span>e_phoff
</span></span><span style="display:flex;"><span>    phnum <span style="color:#f92672">=</span> ehdr<span style="color:#f92672">.</span>e_phnum
</span></span><span style="display:flex;"><span>    phdrtbl <span style="color:#f92672">=</span> bytes[phoff:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ehdr<span style="color:#f92672">.</span>e_shoff <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    ehdr<span style="color:#f92672">.</span>e_shnum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    ehdr<span style="color:#f92672">.</span>e_shstrndx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(phnum):
</span></span><span style="display:flex;"><span>        phdr <span style="color:#f92672">=</span> Elf32Phdr(phdrtbl[:<span style="color:#ae81ff">0x20</span>])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> phdr<span style="color:#f92672">.</span>p_type <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            poffs <span style="color:#f92672">=</span> phdr<span style="color:#f92672">.</span>p_offset
</span></span><span style="display:flex;"><span>            psize <span style="color:#f92672">=</span> phdr<span style="color:#f92672">.</span>p_filesz
</span></span><span style="display:flex;"><span>            paddr <span style="color:#f92672">=</span> phdr<span style="color:#f92672">.</span>p_vaddr
</span></span><span style="display:flex;"><span>            phdata <span style="color:#f92672">=</span> GetManyBytes(paddr, psize)
</span></span><span style="display:flex;"><span>            file<span style="color:#f92672">.</span>seek(poffs)
</span></span><span style="display:flex;"><span>            file<span style="color:#f92672">.</span>write(phdata)
</span></span><span style="display:flex;"><span>        phdrtbl <span style="color:#f92672">=</span> phdrtbl[<span style="color:#ae81ff">0x20</span>:]
</span></span><span style="display:flex;"><span>    file<span style="color:#f92672">.</span>seek(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    file<span style="color:#f92672">.</span>write(bytes[:<span style="color:#ae81ff">16</span>] <span style="color:#f92672">+</span> str(ehdr))   
</span></span><span style="display:flex;"><span>    file<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>    print <span style="color:#e6db74">&#34;[+] Elf Dumped&#34;</span></span></span></code></pre></div>
Once on disk we see that the dumped file is a 1.3M statically linked binary:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ELF Header:
</span></span><span style="display:flex;"><span>  Magic:   <span style="color:#ae81ff">7f</span> <span style="color:#ae81ff">45</span> <span style="color:#ae81ff">4</span>c <span style="color:#ae81ff">46</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 
</span></span><span style="display:flex;"><span>  Class:                             ELF32
</span></span><span style="display:flex;"><span>  Data:                              <span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">&#39;</span>s complement, little endian
</span></span><span style="display:flex;"><span>  Version:                           <span style="color:#ae81ff">1</span> (current)
</span></span><span style="display:flex;"><span>  OS<span style="color:#f92672">/</span>ABI:                            UNIX <span style="color:#f92672">-</span> GNU
</span></span><span style="display:flex;"><span>  ABI Version:                       <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  Type:                              <span style="color:#a6e22e">EXEC</span> (Executable file)
</span></span><span style="display:flex;"><span>  Machine:                           Intel <span style="color:#ae81ff">80386</span>
</span></span><span style="display:flex;"><span>  Version:                           <span style="color:#ae81ff">0x1</span>
</span></span><span style="display:flex;"><span>  Entry point address:               <span style="color:#ae81ff">0x8048d86</span>
</span></span><span style="display:flex;"><span>  Start of program headers:          <span style="color:#ae81ff">52</span> (bytes into file)
</span></span><span style="display:flex;"><span>  Start of section headers:          <span style="color:#ae81ff">0</span> (bytes into file)
</span></span><span style="display:flex;"><span>  Flags:                             <span style="color:#ae81ff">0x0</span>
</span></span><span style="display:flex;"><span>  Size of this header:               <span style="color:#ae81ff">52</span> (bytes)
</span></span><span style="display:flex;"><span>  Size of program headers:           <span style="color:#ae81ff">32</span> (bytes)
</span></span><span style="display:flex;"><span>  Number of program headers:         <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>  Size of section headers:           <span style="color:#ae81ff">40</span> (bytes)
</span></span><span style="display:flex;"><span>  Number of section headers:         <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  Section header string table index: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Program Headers:
</span></span><span style="display:flex;"><span>  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
</span></span><span style="display:flex;"><span>  LOAD           <span style="color:#ae81ff">0x000000</span> <span style="color:#ae81ff">0x08048000</span> <span style="color:#ae81ff">0x08048000</span> <span style="color:#ae81ff">0x14ba2e</span> <span style="color:#ae81ff">0x14ba2e</span> R E <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>  LOAD           <span style="color:#ae81ff">0x14bea4</span> <span style="color:#ae81ff">0x08194ea4</span> <span style="color:#ae81ff">0x08194ea4</span> <span style="color:#ae81ff">0x02374</span> <span style="color:#ae81ff">0x06460</span> RW  <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>  NOTE           <span style="color:#ae81ff">0x0000f4</span> <span style="color:#ae81ff">0x080480f4</span> <span style="color:#ae81ff">0x080480f4</span> <span style="color:#ae81ff">0x00044</span> <span style="color:#ae81ff">0x00044</span> R   <span style="color:#ae81ff">0x4</span>
</span></span><span style="display:flex;"><span>  TLS            <span style="color:#ae81ff">0x14bea4</span> <span style="color:#ae81ff">0x08194ea4</span> <span style="color:#ae81ff">0x08194ea4</span> <span style="color:#ae81ff">0x00014</span> <span style="color:#ae81ff">0x00038</span> R   <span style="color:#ae81ff">0x4</span>
</span></span><span style="display:flex;"><span>  GNU_STACK      <span style="color:#ae81ff">0x000000</span> <span style="color:#ae81ff">0x00000000</span> <span style="color:#ae81ff">0x00000000</span> <span style="color:#ae81ff">0x00000</span> <span style="color:#ae81ff">0x00000</span> RW  <span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>  GNU_RELRO      <span style="color:#ae81ff">0x14bea4</span> <span style="color:#ae81ff">0x08194ea4</span> <span style="color:#ae81ff">0x08194ea4</span> <span style="color:#ae81ff">0x0115c</span> <span style="color:#ae81ff">0x0115c</span> R   <span style="color:#ae81ff">0x1</span></span></span></code></pre></div>
<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li>Tracing until decoding of Elf header and program header table.</li>
<li>Set hardware breapoint on execution at entry-point address in the Elf header.</li>
<li>Profit.</li>
</ul>
<!-- raw HTML omitted -->
<p>In the next write up I will cover the analysis process of the unpacked file.
Thanks for reading and I hope you learned something useful from this post!.</p>
<p>n4x0r.</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Ignacio Sanmillan</span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
