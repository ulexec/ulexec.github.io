<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Notes on Mach IPC :: ulexec.github.io</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Introduction This blog is intended to be a dedicated effort to structure information in relation to Mach Messages in a way that I can remember and use as a reference for the future.
Often as a vulnerability researcher, attack-surfaces involving compromising other adjacent processes relative to a preliminar target are increasingly important with today&amp;rsquo;s enforced mitigations (specially in the SBX realm), and having a good understanding of the internals of the underlying technology which makes this inter-process communication mechanism possible is vital to understand and tackle adjacent attack surfaces." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://ulexec.github.io/post/2022-12-01-xnu_ipc/" />






  
  
  
  
  
  <link rel="stylesheet" href="https://ulexec.github.io/styles.css">







  <link rel="shortcut icon" href="https://ulexec.github.io/img/theme-colors/blue.png">
  <link rel="apple-touch-icon" href="https://ulexec.github.io/img/theme-colors/blue.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Notes on Mach IPC">
<meta property="og:description" content="Introduction This blog is intended to be a dedicated effort to structure information in relation to Mach Messages in a way that I can remember and use as a reference for the future.
Often as a vulnerability researcher, attack-surfaces involving compromising other adjacent processes relative to a preliminar target are increasingly important with today&amp;rsquo;s enforced mitigations (specially in the SBX realm), and having a good understanding of the internals of the underlying technology which makes this inter-process communication mechanism possible is vital to understand and tackle adjacent attack surfaces." />
<meta property="og:url" content="https://ulexec.github.io/post/2022-12-01-xnu_ipc/" />
<meta property="og:site_name" content="ulexec.github.io" />

  
    <meta property="og:image" content="https://ulexec.github.io/img/favicon/blue.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="writeup" />


  <meta property="article:published_time" content="2022-11-28 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/post/">
  <div class="logo">
    ulexec.github.io
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;â–¾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/post/">Archives</a></li>
        
      
        
          <li><a href="/publications/">Publications</a></li>
        
      
        
          <li><a href="/projects/">Projects</a></li>
        
      
        
          <li><a href="/bugs/">Bugs</a></li>
        
      
        
          <li><a href="/about/">About</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/post/" >Archives</a></li>
        
      
        
          <li><a href="/publications/" >Publications</a></li>
        
      
        
          <li><a href="/projects/" >Projects</a></li>
        
      
        
          <li><a href="/bugs/" >Bugs</a></li>
        
      
        
          <li><a href="/about/" >About</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://ulexec.github.io/post/2022-12-01-xnu_ipc/">Notes on Mach IPC</a>
  </h1>
  <div class="post-meta"><time class="post-date">2022-11-28</time><span class="post-author">ulexec</span></div>

  
    <span class="post-tags">
      
      #<a href="https://ulexec.github.io/tags/macos/">macOS</a>&nbsp;
      
      #<a href="https://ulexec.github.io/tags/ipc/">IPC</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>This blog is intended to be a dedicated effort to structure information in relation to Mach Messages in a way that I can remember and use as a reference for the future.</p>
<p>Often as a vulnerability researcher, attack-surfaces involving compromising other adjacent processes relative to a preliminar target are increasingly important with today&rsquo;s enforced mitigations (specially in the SBX realm), and having a good understanding of the internals of the underlying technology which makes this inter-process communication mechanism possible is vital to understand and tackle adjacent attack surfaces.</p>
<h1 id="overview">Overview<a href="#overview" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>XNU is the computer operating system kernel in use on macOS operating system, and released as free and open-source software as part of the Darwin OS, which in addition to macOS is also the basis for the Apple TV Software, iOS, iPadOS, watchOS, and tvOS OSes. XNU is an abbreviation of <code>X is Not Unix</code>.</p>
<p>XNU is a hybrid kernel, containing features of both monolithic and microkernel designs. An overview of the comparison of the distinct characteristics between monolithic and microkernel architctures are the following:</p>
<ul>
<li>
<p>A microkernel is a kernel type that implements an operating system by providing methods, including low-level address space management, IPC, and thread management. On the other hand, a monolithic kernel is a type of kernel in which the complete OS runs in the kernel space.</p>
</li>
<li>
<p>Microkernels run user and kernel services in different address spaces. On the other hand, the monolithic kernel runs both kernel and user services in the same address space. In microkernels, only essential processes like IPC, memory management, and scheduling take place in kernel space.</p>
</li>
<li>
<p>The execution of a microkernel is slower because communication between the system&rsquo;s application and hardware is established by message passing. On the other hand, the execution of the monolithic kernel is faster because the system call establishes the communication of the system&rsquo;s application and hardware.</p>
</li>
<li>
<p>Microkernels use the messaging queues to achieve IPC. On the other hand, monolithic kernels use sockets and signals to achieve IPC.
The microkernel size is small than the monolithic kernel because only the kernel services run in the kernel address space. On the other hand, the monolithic kernel size is larger because both user and kernel services run in the same address space.</p>
</li>
<li>
<p>Microkernels are more secure than the monolithic kernels because the operating system is unchanged if a service fails in a microkernel. On the other hand, if a service fails in a monolithic kernel, the entire system fails.</p>
</li>
<li>
<p>Microkernels are simple to extend as new services are added in user address space, which is separate from kernel space, and thus the kernel doesn&rsquo;t need to be updated. On the other hand, the complete kernel must be updated if a new service is used in a monolithic kernel.</p>
</li>
<li>
<p>Microkernel designing needs less code that leads to fewer errors. In contrast, the monolithic kernel requires more code that leads to more errors.</p>
</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d0/OS-structure2.svg#center" alt=""></p>
<p>Running the core of an operating system as separated processes, allows for great flexibility but this often reduces performance due to time-consuming kernel/user mode context switches and overhead stemming from mapping or copying messages between the address spaces of the kernel and that of the service daemons.</p>
<p>Given the challenges of a microkernel design, XNU uses a hybrid design. Much of the functionality lives in the kernel space, but also many subsystems are backed by user space daemons.</p>
<p>Mach messages are relevant in this context as it implements the core technology for IPC communication between kernel and user-space tasks in the Mach microkernel architecture.</p>
<h1 id="mach-messages">Mach Messages<a href="#mach-messages" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Mach messages are a message queue mechanism based IPC mechanism, in which endpoints are required to receive and send messages through. In Mach, these endpoints are called mach ports. Mach ports are a kernel level abstraction and are not directly exposed to user-space, instead these mach ports can be accessed through port rights.</p>
<p>Each task has its own namespace of port rights, and these are represented as 32bit integers. Is due to this reason that many Mach port APIs take an explicit task argument in order to disambiguate the respective mach port name.</p>
<p>Is important to note that mach ports are not only used to establish a means of IPC communication for the kernel and user-space services, but to also serve as an abstraction for resources. As an example, in user-space all tasks, threads or even semaphores handles are used as port rights to ports representing the underlying resources.</p>
<p>Here for example are some typedefs from <a href="https://opensource.apple.com/source/xnu/xnu-792/osfmk/mach/mach_types.h"><code>mach/mach_types.h</code></a> showcasing this abstraction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * If we are not in the kernel, then these will all be represented by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ports at user-space.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		task_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		thread_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>	mach_port_t		thread_act_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		ipc_space_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		host_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		host_priv_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		host_security_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		processor_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		processor_set_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		processor_set_control_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		semaphore_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		lock_set_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		ledger_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		alarm_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		clock_serv_t;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> mach_port_t		clock_ctrl_t;</span></span></code></pre></div>
<h2 id="mach-ports-and-mach-port-rights">Mach Ports and Mach Port Rights<a href="#mach-ports-and-mach-port-rights" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Mach ports are the IPC primitives under Mach. A mach port is conceptually a message queue maintained by the kernel. Tasks and the kernel itself can enqueue and dequeue messages to/from a port via a port right to that port.</p>
<p>A port right is a handle to a port that allows either sending (enqueuing) or receiving (dequeuing) messages. There are the following kinds of port rights:</p>
<ul>
<li><code>Receive right</code>: allows receiving messages sent to the port.
<ul>
<li>Mach ports are MPSC (multiple-producer, single-consumer) queues, which means that there may only ever be one receive right for each port in the whole system.</li>
</ul>
</li>
<li><code>Send right</code>: allows sending messages to the port.</li>
<li><code>Send-once</code>: allows sending one message to the port and then disappears.</li>
<li><code>Port set</code>: denotes a port set rather than a single port.
<ul>
<li>Dequeuing a message from a port set dequeues a message from one of the ports it contains.</li>
<li>Port sets can be used to listen on several ports simultaneously, a lot like select/poll/epoll/kqueue in Unix.</li>
</ul>
</li>
<li><code>Dead name</code>: This is not an actual port right, but merely a placeholder.
<ul>
<li>When a port is destroyed, all existing port rights to the port turn into dead names.</li>
</ul>
</li>
</ul>
<p>In addition, A port right name is a specific integer value a task uses to refer to a port right it holds, a lot like a file descriptor that a process uses to refer to an open file.
* Sending a port right name, the integer, to another task does not allow it to use the name to access the port right, because the name is only meaningful in the context of the port right namespace of the original task.</p>
<p>Mach ports are an unidirectional communication channel by design. Therefore there can only exists one holder of a receive right to a port, however there can be multiple send right owners.
Rights can be transfered over messages. There can be only one receive right, and this can only be moved (in case it wants to be send to a different task). However, send rights can either be moved or copied to other tasks.</p>
<p>Given a unidirectional channel a bidirectional communication can be established.
The following describes how this process works:</p>
<ol>
<li>Alice is an owner of a receive right to a port</li>
<li>Bob is an owner of a send right to the same port</li>
<li>Bob then allocates a Mach port with a receive right</li>
<li>Bob inserts a send right to this new mach port</li>
<li>He transfers the send right to this port over a message to Alice</li>
</ol>
<p>Now both Bob and Alice own a receive and send rights to ports they can leverage to communicate with one another. Syncing up the communication over different ports is not very convenient or efficient, therefore a mach message can optionally include a repy port which can be used to send a message response.</p>
<p>In addition to simply send and receive port rights, other port rights can be enforced.
The following values denote port rights (obtained from <a href="https://www.gnu.org/software/hurd/gnumach-doc/Exchanging-Port-Rights.html">this</a> resource) :</p>
<ul>
<li>
<p><code>MACH_MSG_TYPE_MAKE_SEND</code></p>
<p>The message will carry a send right, but the caller must supply a receive right. The send right is created from the receive right, and the receive right&rsquo;s make-send count is incremented.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_COPY_SEND</code></p>
<p>The message will carry a send right, and the caller should supply a send right. The user reference count for the supplied send right is not changed. The caller may also supply a dead name and the receiving task will get <code>MACH_PORT_DEAD</code>.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_MOVE_SEND</code></p>
<p>The message will carry a send right, and the caller should supply a send right. The user reference count for the supplied send right is decremented, and the right is destroyed if the count becomes zero. Unless a receive right remains, the name becomes available for recycling. The caller may also supply a dead name, which loses a user reference, and the receiving task will get<code>MACH_PORT_DEAD</code>.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_MAKE_SEND_ONCE</code></p>
<p>The message will carry a send-once right, but the caller must supply a receive right. The send-once right is created from the receive right.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_MOVE_SEND_ONCE</code></p>
<p>The message will carry a send-once right, and the caller should supply a send-once right. The caller loses the supplied send-once right. The caller may also supply a dead name, which loses a user reference, and the receiving task will get <code>MACH_PORT_DEAD</code>.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_MOVE_RECEIVE</code></p>
<p>The message will carry a receive right, and the caller should supply a receive right. The caller loses the supplied receive right, but retains any send rights with the same name.</p>
</li>
</ul>
<p>The following msgt_name values in a received message indicate that it carries port rights:</p>
<ul>
<li>
<p><code>MACH_MSG_TYPE_PORT_SEND</code>
This name is an alias for <code>MACH_MSG_TYPE_MOVE_SEND</code>. The message carried a send right. If the receiving task already has send and/or receive rights for the port, then that name for the port will be reused. Otherwise, the new right will have a new name. If the task already has send rights, it gains a user reference for the right (unless this would cause the user-reference count to overflow). Otherwise, it acquires the send right, with a user-reference count of one.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_PORT_SEND_ONCE</code>
This name is an alias for <code>MACH_MSG_TYPE_MOVE_SEND_ONCE</code>. The message carried a send-once right. The right will have a new name.</p>
</li>
<li>
<p><code>MACH_MSG_TYPE_PORT_RECEIVE</code>
This name is an alias for <code>MACH_MSG_TYPE_MOVE_RECEIVE</code>. The message carried a receive right. If the receiving task already has send rights for the port, then that name for the port will be reused. Otherwise, the right will have a new name.</p>
</li>
</ul>
<p>If a message carries a send or send-once right, and the port dies while the message is in transit, then the receiving task will get <code>MACH_PORT_DEAD</code> instead of a right.</p>
<h2 id="establishing-a-connection">Establishing a connection<a href="#establishing-a-connection" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>In Darwin, there is a centralised broker service, also known as the bootstrap server, which serves as an orchestrator to establish connections between tasks/services.
The role of this bootstrap server in XNU is fulfilled by <code>launchd</code> (although before launchd, the init process and the bootstrap server where separated).</p>
<p>Each spawned service/task holds an implicit send right to the broker service. The bootstrap server is resposible for service registration and lookup, and allows to establish a connection between two parties. As an example to showcase the role of the bootstrap server, the following describes a scenario in which two tasks establish a connection via the broker server:</p>
<ol>
<li>Alice registers her service with the bootstrap server using some name. eg <code>com.test-service.alice</code>.</li>
<li>Registration in practice means that Alice grants the broker a send right to a port Alice holds a receive right to.</li>
<li>Bob queries the bootstrap server for the <code>com.test-service.alice</code> name, and the broker server copies the send right registered for that tasks, which was sent by Alice previously.</li>
<li>Now Bob holds a send right to a port in which Alice holds a receive right.</li>
</ol>
<h2 id="messages">Messages<a href="#messages" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Mach messages are used to exchange data over Mach ports. The following is an overview of the structure of mach messages:</p>
<p><img src="http://blog.wuntee.sexy/resources/2015-06-04-reaching-the-mach-layer/mach_msg_header.jpg#center" alt=""></p>
<p>As shown in the diagram above, a mach message is composed of a header and a body. Mach message header conforms to a structure of type <code>mach_msg_header_t</code>. This structure is defined as follows:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_bits_t       msgh_bits;
</span></span><span style="display:flex;"><span>  mach_msg_size_t       msgh_size;
</span></span><span style="display:flex;"><span>  mach_port_t           msgh_remote_port;
</span></span><span style="display:flex;"><span>  mach_port_t           msgh_local_port;
</span></span><span style="display:flex;"><span>  mach_port_name_t      msgh_voucher_port;
</span></span><span style="display:flex;"><span>  mach_msg_id_t         msgh_id;
</span></span><span style="display:flex;"><span>} mach_msg_header_t;</span></span></code></pre></div>A brief description of these fields is the following:</p>
<ul>
<li><code>msgh_bits</code> - options and message metadata, such as disposition of port rights in the message</li>
<li><code>msgh_size</code> - total message size, including header</li>
<li><code>msgh_remote_port</code> - remote Mach port, used as the destination when sending a message, or a reply port when receiving</li>
<li><code>msgh_local_port</code> - local Mach port, the port the message was received on, or a reply port when sending a message</li>
<li><code>msgh_voucher_port</code> - port identifying a Mach Voucher, that&rsquo;s an optional field</li>
<li><code>msgh_id</code> - user defined message identifier</li>
</ul>
<p>When receiving a message, messages can optionally contain a field known as trailer at the end of the message. Trailers contain information about the message. Trailers will be covered in more detailed in a future section.</p>
<h1 id="unidirectional-message-example">Unidirectional Message Example<a href="#unidirectional-message-example" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>This section will describe a minimalist example of an unidirectional exchange between two parties over mach messages.
This will be divided into two parts, being the server and client side roles.</p>
<h2 id="server-side">Server Side<a href="#server-side" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The server side functionality is summerized in the following steps:</p>
<ol>
<li>Create a Mach port receive right</li>
<li>Add a send right to the port for the bootstrap server to use</li>
<li>Retrieving a Mach port to communicate with the broker</li>
<li>Registering our service</li>
<li>Message receiving</li>
</ol>
<p>The full source code for the server is shown as follows:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// server.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    mach_msg_header_t header;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>    mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_port_name_t recv_port;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (mach_port_insert_right(task, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bootstrap_register(bootstrap_port, <span style="color:#e6db74">&#34;com.test-service.alice&#34;</span>, recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>            (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,  <span style="color:#75715e">// msg 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            MACH_RCV_MSG,                   <span style="color:#75715e">// option            
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#ae81ff">0</span>,                              <span style="color:#75715e">// send size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">sizeof</span>(message),                <span style="color:#75715e">// receive size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            recv_port,                      <span style="color:#75715e">// recv_name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            MACH_MSG_TIMEOUT_NONE,          <span style="color:#75715e">// timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            MACH_PORT_NULL);                <span style="color:#75715e">// notify port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;[+] Received message!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">msgh_id</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.header.msgh_id);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">message.body</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.body);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<h3 id="create-a-mach-port-receive-right">Create a Mach port receive right<a href="#create-a-mach-port-receive-right" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Defining our message structure composed of a <code>mach_msg_header_t</code> header, a body and a default <code>mach_msg_trailer_t</code>, although this last one is not neccesary for now.</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} MachMessage;</span></span></code></pre></div>
Allocating a new mach port
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_name_t recv_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div></p>
<h3 id="add-a-send-right-to-the-port-for-the-bootstrap-server-to-use">Add a send right to the port for the bootstrap server to use<a href="#add-a-send-right-to-the-port-for-the-bootstrap-server-to-use" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Inserting a new send right into our mach port
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_insert_right(task, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div></p>
<h3 id="registering-service-to-bootstrap-server">Registering service to bootstrap server<a href="#registering-service-to-bootstrap-server" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Retrieving the port of the bootstrap server
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div>
Register mach port to service name via the bootstrap server
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (bootstrap_register(bootstrap_port, <span style="color:#e6db74">&#34;com.test-service.alice&#34;</span>, recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div></p>
<h3 id="wait-to-receive-messages">Wait to receive messages<a href="#wait-to-receive-messages" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Wait in an infinite loop for messages to arrive
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>    mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>        (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,  <span style="color:#75715e">// msg 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_RCV_MSG,                   <span style="color:#75715e">// option            
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,                              <span style="color:#75715e">// send size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">sizeof</span>(message),                <span style="color:#75715e">// receive size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        recv_port,                      <span style="color:#75715e">// recv_name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_MSG_TIMEOUT_NONE,          <span style="color:#75715e">// timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_PORT_NULL);                <span style="color:#75715e">// notify port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[+] Received message!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">msgh_id</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.header.msgh_id);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">message.body</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.body);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<h2 id="client-side">Client Side<a href="#client-side" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The server side functionality is summerized in the following steps:</p>
<ol>
<li>Retrieve the bootstrap server port to query it for the service port</li>
<li>Query bootstrap for the service port</li>
<li>Setup message header</li>
<li>Fill message body</li>
<li>Send the message</li>
</ol>
<p>The full source of the client is shown as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// client.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_init.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/task.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    mach_msg_header_t header;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    mach_port_name_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_port_t port;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bootstrap_look_up(bootstrap_port, <span style="color:#e6db74">&#34;com.test-service.alice&#34;</span>, <span style="color:#f92672">&amp;</span>port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Copy send right to the remote port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>        MACH_MSG_TYPE_COPY_SEND,        <span style="color:#75715e">// remote
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,                              <span style="color:#75715e">// local
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,                              <span style="color:#75715e">// voucher
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>);                             <span style="color:#75715e">// other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    message.header.msgh_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strcpy(message.body, <span style="color:#e6db74">&#34;Some Message Body Data :)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>        (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,    <span style="color:#75715e">// msg 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_SEND_MSG,                    <span style="color:#75715e">// option
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">sizeof</span>(message),                  <span style="color:#75715e">// send size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,                                <span style="color:#75715e">// recv size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_PORT_NULL,                   <span style="color:#75715e">// recv name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_MSG_TIMEOUT_NONE,            <span style="color:#75715e">// timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MACH_PORT_NULL);                  <span style="color:#75715e">// notify port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;[-] Failed mach_msg: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sleep(<span style="color:#ae81ff">120</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="retrieve-target-service-port">Retrieve target service port<a href="#retrieve-target-service-port" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Retrieve the bootstrap server prot
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  mach_port_name_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div>Retrieve the target service port via the bootstrap server
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  mach_port_t port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (bootstrap_look_up(bootstrap_port, <span style="color:#e6db74">&#34;com.test-service.alice&#34;</span>, <span style="color:#f92672">&amp;</span>port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div></p>
<h3 id="setup-message-header">Setup message header<a href="#setup-message-header" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>One important macro to cover is the macro <code>MACH_MSGH_BITS_SET</code>. It serves to set appropiate bits in <code>mach_msg_bits_t</code> representing a given port right disposition. This macro is defined in <a href="https://opensource.apple.com/source/xnu/xnu-4570.41.2/osfmk/mach/message.h.auto.html"><code>mach/message.h.auto.html</code></a>:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/* setter macros for the bits */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MACH_MSGH_BITS(remote, local)  </span><span style="color:#75715e">/* legacy */</span><span style="color:#75715e">		\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		((remote) | ((local) &lt;&lt; 8))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define	MACH_MSGH_BITS_SET_PORTS(remote, local, voucher)	\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	(((remote) &amp; MACH_MSGH_BITS_REMOTE_MASK) | 		\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 (((local) &lt;&lt; 8) &amp; MACH_MSGH_BITS_LOCAL_MASK) | 	\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 (((voucher) &lt;&lt; 16) &amp; MACH_MSGH_BITS_VOUCHER_MASK))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MACH_MSGH_BITS_SET(remote, local, voucher, other)	\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	(MACH_MSGH_BITS_SET_PORTS((remote), (local), (voucher)) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 | ((other) &amp;~ MACH_MSGH_BITS_PORTS_MASK))</span></span></span></code></pre></div>
Here we can see that for <code>remote</code>, <code>local</code> and <code>voucher</code>, is setting bits on specific binary masks. These binary masks correspond to the following:</p>
<ul>
<li>
<p><code>MACH_MSGH_BITS_REMOTE_MASK</code>:</p>
<p>Encodes <code>mach_msg_type_name_t</code> values that specify the port rights in the <code>msgh_remote_port</code> field.</p>
<p>The value must specify a send or send-once right for the destination of the message.</p>
</li>
<li>
<p><code>MACH_MSGH_BITS_LOCAL_MASK</code>:</p>
<p>Encodes <code>mach_msg_type_name_t</code> values that specify the port rights in the <code>msgh_local_port</code> field.</p>
<p>If the value doesn&rsquo;t specify a send or send-once right for the message&rsquo;s reply port, it must be zero and <code>msgh_local_port</code> must be <code>MACH_PORT_NULL</code>.</p>
</li>
<li>
<p><code>MACH_MSGH_BITS_COMPLEX</code>:
The complex bit must be specified if the message body contains additional port rights or out-of-line memory regions.</p>
</li>
</ul>
<p>Basically these mask, estipulate to which port the port right disposition is being applied (remote port, local port, or OOL port rights).</p>
<p>These bits applied to these binary masks correspond to a specified port disposition, which indicates the kernel what to do with the port specified in the mach message header.</p>
<p>Here we are usig the <code>MACH_MSGH_BITS_SET</code> to specify that the send right should be copied to the remote port with the value <code>MACH_MSG_TYPE_COPY_SEND</code>. This may seem a bit weird at first, however lets remember that port disposition serve to direct the kernel how to process port rights for each port. In this case, we are directing the kernel to copy the send right of the registered service shared by the bootstrap server to the remote port in order for the message to be delivered to the destination endpoint sucessfully.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  MachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Copy send right to the remote port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,        <span style="color:#75715e">// remote
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0</span>,                              <span style="color:#75715e">// local
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0</span>,                              <span style="color:#75715e">// voucher
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0</span>);                             <span style="color:#75715e">// other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  message.header.msgh_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(message);</span></span></code></pre></div>
<h3 id="send-the-message">Send the message<a href="#send-the-message" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Here we simply populate the message body, and we proceed to call <code>mach_msg</code> with the <code>MACH_SEND_MSG</code> option
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  strcpy(message.body, <span style="color:#e6db74">&#34;Some Message Body Data :)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,    <span style="color:#75715e">// msg 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MACH_SEND_MSG,                    <span style="color:#75715e">// option
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sizeof</span>(message),                  <span style="color:#75715e">// send size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0</span>,                                <span style="color:#75715e">// recv size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MACH_PORT_NULL,                   <span style="color:#75715e">// recv name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MACH_MSG_TIMEOUT_NONE,            <span style="color:#75715e">// timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MACH_PORT_NULL);                  <span style="color:#75715e">// notify port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[-] Failed mach_msg: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div></p>
<h1 id="bidirectional-message-example">Bidirectional Message Example<a href="#bidirectional-message-example" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>In this example we will extend the previous example to support reply messages.</p>
<p>The server code is the following:</p>
<h2 id="server">Server<a href="#server" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// server.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  MachMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// allocating a new ephemeral mach port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_port_name_t recv_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inserting a port send right to newly allocated port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (mach_port_insert_right(task, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND) 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// retrieving the bootstrap server port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(task_get_bootstrap_port(task, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// register ourselves with to the bootstrap server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (bootstrap_register(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// waiting for messages
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  printf(<span style="color:#e6db74">&#34;[*] Waiting for messages</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(true) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// receiving message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ReceivedMachMessage received_message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>received_message,
</span></span><span style="display:flex;"><span>      MACH_RCV_MSG, 
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span>(received_message),
</span></span><span style="display:flex;"><span>      recv_port,
</span></span><span style="display:flex;"><span>      MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;[-] Failed to receive mach message&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[+] Got message!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[+] </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">remote port:</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, received_message.message.header.msgh_remote_port);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[+] </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">body: </span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, received_message.message.body);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (received_message.message.header.msgh_remote_port <span style="color:#f92672">==</span> MACH_PORT_NULL) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// crafting reply message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We can use msgh_bits from the received message as it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    response.header.msgh_bits <span style="color:#f92672">=</span> received_message.message.header.msgh_bits
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span> MACH_MSGH_BITS_REMOTE_MASK;
</span></span><span style="display:flex;"><span>    response.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.header.msgh_remote_port;
</span></span><span style="display:flex;"><span>    response.header.msgh_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    response.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(response);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strcpy(response.body, <span style="color:#e6db74">&#34;A response to a sent message&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// sending message reply
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>      MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span>(response),
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL,
</span></span><span style="display:flex;"><span>      MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;[+] Error sending message reply&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>### Using msg_bits to fetch remote reply port
The only thing that is worth to highlight in contrast to the previous example is that, once we have received a mach message, we can use the msg_bits from the initial received message header, and acquire the destination port as the endpoint to send our message to.
This can be seen in the following snippet:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// crafting reply message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We can use msgh_bits from the received message as it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>response.header.msgh_bits <span style="color:#f92672">=</span> received_message.message.header.msgh_bits
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span> MACH_MSGH_BITS_REMOTE_MASK;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// we change the destination port to conform with the one sent on our intial message 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>response.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.header.msgh_remote_port;
</span></span><span style="display:flex;"><span>response.header.msgh_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>response.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(response);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>strcpy(response.body, <span style="color:#e6db74">&#34;A response to a sent message&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// sending message reply
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>    MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span>(response),
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[+] Error sending message reply&#34;</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>With these changes in the server we will be already supporting message replies.</p>
<p>Lets look at the clients to see what changes we need to make clients also conform to messages replies</p>
<h2 id="client">Client<a href="#client" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The full client source is shown below:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// client.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_init.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/task.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  MachMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// retrieving the bootstrap server port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// retrieving port of destination service
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_port_t port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (bootstrap_look_up(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, <span style="color:#f92672">&amp;</span>port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// creating a bew epehemeral mach port dedicated to receive reply messages
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_port_t reply_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>reply_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inserting a send right to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (mach_port_insert_right(task, reply_port, reply_port, MACH_MSG_TYPE_MAKE_SEND) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// crafting initial message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  MachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>  message.header.msgh_local_port <span style="color:#f92672">=</span> reply_port;
</span></span><span style="display:flex;"><span>  message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// we direct the kernel to also make the send right for the local port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MACH_MSG_TYPE_MAKE_SEND,  
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy(message.body, <span style="color:#e6db74">&#34;This is a test message&#34;</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;[*] Sending message to port %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.header.msgh_remote_port);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Sending message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message, 
</span></span><span style="display:flex;"><span>    MACH_SEND_MSG, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> message, 
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[+] Failed to send message</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;[*] Waiting for replies to port %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.header.msgh_local_port);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// waiting for replies
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ReceivedMachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>    MACH_RCV_MSG, 
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> response,
</span></span><span style="display:flex;"><span>    reply_port,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[-] Could not receive mach message&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;[+] Got reply!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">From port:</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, response.message.header.msgh_remote_port);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">body:</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, response.message.body);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
Changes that are worth to highlight are as follows:</p>
<h3 id="allocating-a-new-mach-port-for-replies">Allocating a new mach port for replies<a href="#allocating-a-new-mach-port-for-replies" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>In order to receive replies, we need to allocate a new mach port for doing so.
In order to do this we do this as we did it in the server side, via <code>mach_port_allocate</code>.</p>
<p>In addition, in order for the remote task to be able to send us messages, we need to also insert a send right to our newly created port:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#75715e">// creating a bew epehemeral mach port dedicated to receive reply messages
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_port_t reply_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>reply_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inserting a send right to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (mach_port_insert_right(task, reply_port, reply_port, MACH_MSG_TYPE_MAKE_SEND) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div>
<h3 id="crafting-message-with-reply-port-with-appropiate-port-disposition">Crafting message with reply port with appropiate port disposition<a href="#crafting-message-with-reply-port-with-appropiate-port-disposition" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Now we have to craft the initial message we will be sending to the server.
In order to do so we need to set the apporpiate disposition not only for the remote port, but also to our local port dedicated for the remote endpoit to send us replies.</p>
<p>In order to do this we have to use the macro <code>MACH_MSGH_BITS_SET</code> again, setting the <code>MACH_MSG_TYPE_COPY_SEND</code> disposition for the remote port&rsquo;s port right to be able to send the message in the first place, but also the <code>MACH_MSG_TYPE_MAKE_SEND</code> dispositioin for our local port, which is dedicated to receive message replies. With this, this message will send our local port send right to the remote endpoint, in order for it to be able to send us replies.</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#75715e">// crafting initial message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  MachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>  message.header.msgh_local_port <span style="color:#f92672">=</span> reply_port;
</span></span><span style="display:flex;"><span>  message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// we direct the kernel to also make the send right for the local port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MACH_MSG_TYPE_MAKE_SEND,  
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy(message.body, <span style="color:#e6db74">&#34;This is a test message&#34;</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;[*] Sending message to port %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, message.header.msgh_remote_port);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Sending message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message, 
</span></span><span style="display:flex;"><span>    MACH_SEND_MSG, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> message, 
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL
</span></span><span style="display:flex;"><span>  );</span></span></code></pre></div>
Once we do that we can send the message, and our local_port field in the mach message header will be converted to the remote_port field when the remote endpoint receives our message.</p>
<h3 id="waiting-for-replies-from-remote-task">Waiting for replies from remote task<a href="#waiting-for-replies-from-remote-task" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Once we have sent our local port send right to the remote endpoint, all we have to do now is to listen to replies in our local port</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// waiting for replies
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ReceivedMachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>    MACH_RCV_MSG, 
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> response,
</span></span><span style="display:flex;"><span>    reply_port,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL);</span></span></code></pre></div>
<h1 id="complex-message-example">Complex Message Example<a href="#complex-message-example" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>In this section we will modify the previous example in order to showcase how can we use complex mach messages in order to send mach ports to a destinatary, instead of using the local_port field in the mach message header.</p>
<h2 id="server-1">Server<a href="#server-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The full source of the server application can be shown below:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// server.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_port_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} PortMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  PortMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedPortMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MSG_ID_PORT 1337
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_name_t recv_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mach_port_insert_right(task, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND) 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(bootstrap_register(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(true) {
</span></span><span style="display:flex;"><span>    ReceivedPortMachMessage received_message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>received_message,
</span></span><span style="display:flex;"><span>      MACH_RCV_MSG,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span> received_message,
</span></span><span style="display:flex;"><span>      recv_port, 
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      puts(<span style="color:#e6db74">&#34;[-] Failed to receive message&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (received_message.message.header.msgh_id <span style="color:#f92672">!=</span> MSG_ID_PORT) {
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;[-] Received invalid message id: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, received_message.message.header.msgh_id);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[*] Message received!</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">Port %d received in message</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>      received_message.message.descriptor.name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    response.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>      received_message.message.descriptor.disposition,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    response.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.descriptor.name;
</span></span><span style="display:flex;"><span>    response.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> response;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strcpy(response.body, <span style="color:#e6db74">&#34;A sample response&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>      MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span> response,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      puts(<span style="color:#e6db74">&#34;[+] Error sending message reply&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>### Mach message layout for complex messages
On important thing to higlight is that the type definitions of our mach messages have to be defined slightly different to support complex messages. Lets remember that for complex messages, we will have
the mach message header, an additional <code>mach_msg_size_t</code> field denoting the number of subsequent descriptors, and then an array of descriptors, which in our case for sake of simplicity, we only defined one descriptor of type <code>mach_msg_port_descriptor_t</code>, although other descriptor types are supported such as OOL (out-of-line) descriptors which we will be covering next. For the sake of this example the following are the defined message types:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_port_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} PortMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  PortMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedPortMachMessage;</span></span></code></pre></div>
Note that in our type definition for <code>PortMachMessage</code> type, we put a <code>mach_msg_size_t</code> field called <code>msgh_descriptor_count</code> right after the <code>mach_msg_header_t</code> member. One could instead use the <code>mach_msg_body_t</code> type to define the &lsquo;body&rsquo; of the message, although it seems a bit misleading because this field only contains one member called <code>msgh_descriptor_count</code> as shown below, but both of these declarations are valid.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    mach_msg_size_t  msgh_descriptor_count;
</span></span><span style="display:flex;"><span>} mach_msg_body_t;</span></span></code></pre></div>
<h3 id="retrieving-remote-port-disposition-for-message-reply">Retrieving remote port disposition for message reply<a href="#retrieving-remote-port-disposition-for-message-reply" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>In the previous example we actually needed to handle the port disposition manually by applying a binary mask to the reply message message header msgh_bits field.</p>
<p>However, for this scenario since we are using a complex message with a port descriptor, we can obstain the port disposition directly from the port descriptor&rsquo;s name field in the received message.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>MachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>response.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    received_message.message.descriptor.disposition,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>response.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.descriptor.name;
</span></span><span style="display:flex;"><span>response.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> response;</span></span></code></pre></div>
<h2 id="client-1">Client<a href="#client-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Now we will cover the changes we will have to make to support complex messages with port descriptors in our client.</p>
<p>The following is the full source of the client:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// client.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_init.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/task.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_port_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} PortMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  MachMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MSG_ID_PORT 1337
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(bootstrap_look_up(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, <span style="color:#f92672">&amp;</span>port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t reply_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>reply_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mach_port_insert_right(task, reply_port, reply_port, MACH_MSG_TYPE_MAKE_SEND) 
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PortMachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_MSGH_BITS_COMPLEX
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  message.header.msgh_id <span style="color:#f92672">=</span> MSG_ID_PORT;
</span></span><span style="display:flex;"><span>  message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message;
</span></span><span style="display:flex;"><span>  message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  message.msgh_descriptor_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  message.descriptor.name <span style="color:#f92672">=</span> reply_port;
</span></span><span style="display:flex;"><span>  message.descriptor.disposition <span style="color:#f92672">=</span> MACH_MSG_TYPE_MAKE_SEND;
</span></span><span style="display:flex;"><span>  message.descriptor.type <span style="color:#f92672">=</span> MACH_MSG_PORT_DESCRIPTOR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,
</span></span><span style="display:flex;"><span>    MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> message,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;[-] Failed to send mach message&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ReceivedMachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>    MACH_RCV_MSG,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> response,
</span></span><span style="display:flex;"><span>    reply_port,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;[-] Failed to receive mach message&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;[*] Response received</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">body: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, response.message.body);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="set-the-complex-bit-in-the-message-header">Set the complex bit in the message header<a href="#set-the-complex-bit-in-the-message-header" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>One thing that is easy to overlook to craft complex messages, is to set the appropiate bit in the mach message header to denote the message is indeed complex. We can do this with the macro <code>MACH_MSGH_BITS_SET</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PortMachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_MSGH_BITS_COMPLEX
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div>
<h3 id="crafting-a-complex-message">Crafting A Complex Message<a href="#crafting-a-complex-message" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>In contrast with previous examples, appart from populating the header of our mach message with a <code>msgh_id</code> (optional), <code>msgh_size</code> and <code>msgh_remote_port</code> fields, we need to also populate our port descriptor. In order to do this we need to put the port name under the descriptor&rsquo;s name field, the port disposition under the descritor&rsquo;s disposition field and lastly the type to reflect that our descriptor is of type <code>MACH_MSG_PORT_DESCRIPTOR</code>. We can do all of this as follows:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>message.header.msgh_id <span style="color:#f92672">=</span> MSG_ID_PORT;
</span></span><span style="display:flex;"><span>message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message;
</span></span><span style="display:flex;"><span>message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>message.msgh_descriptor_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>message.descriptor.name <span style="color:#f92672">=</span> reply_port;
</span></span><span style="display:flex;"><span>message.descriptor.disposition <span style="color:#f92672">=</span> MACH_MSG_TYPE_MAKE_SEND;
</span></span><span style="display:flex;"><span>message.descriptor.type <span style="color:#f92672">=</span> MACH_MSG_PORT_DESCRIPTOR;</span></span></code></pre></div># Complex Message Server with DispatchQueue Example
Although not entirely relevant for the subject in question of this post, I also wanted to document how we can handle mach messages with a dedicated GCD dispatch queue. Is very simple to implement, and provides handling of concurrent/serial, aync/sync connections much easier. This design pattern is also followed by many large projects which has to handle a high volume of mach messages for IPC communication. As an example, WebKit implements a similar but much more elaborated approach to send/receive mach messages to WebKit XPC services. In any case, to showcase the concept, the server of previous examples its been rewritten to handle incoming mach messages in an dedicated dispatch queue. The source code of this server is the follwing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// server.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;dispatch/dispatch.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_port_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} PortMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  PortMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedPortMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MSG_ID_PORT 1337
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_name_t recv_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mach_port_insert_right(task, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND) 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(bootstrap_register(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, recv_port) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  dispatch_source_t port_source <span style="color:#f92672">=</span> dispatch_source_create(
</span></span><span style="display:flex;"><span>    DISPATCH_SOURCE_TYPE_MACH_RECV,
</span></span><span style="display:flex;"><span>    recv_port,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    dispatch_queue_create(<span style="color:#e6db74">&#34;com.service.MessageQueue&#34;</span>, DISPATCH_QUEUE_CONCURRENT)
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  dispatch_source_set_event_handler(port_source, <span style="color:#f92672">^</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    ReceivedPortMachMessage received_message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>received_message,
</span></span><span style="display:flex;"><span>      MACH_RCV_MSG,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span> received_message,
</span></span><span style="display:flex;"><span>      recv_port, 
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      puts(<span style="color:#e6db74">&#34;[-] Failed to receive message&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (received_message.message.header.msgh_id <span style="color:#f92672">!=</span> MSG_ID_PORT) {
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;[-] Received invalid message id: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, received_message.message.header.msgh_id);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[*] Message received!</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">Port %d received in message</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>      received_message.message.descriptor.name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    response.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>      received_message.message.descriptor.disposition,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    response.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.descriptor.name;
</span></span><span style="display:flex;"><span>    response.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> response;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strcpy(response.body, <span style="color:#e6db74">&#34;A sample response&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>      MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span> response,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      puts(<span style="color:#e6db74">&#34;[+] Error sending message reply&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  dispatch_resume(port_source);
</span></span><span style="display:flex;"><span>  sleep(<span style="color:#ae81ff">120</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="creating-a-dispatch-source">Creating a dispatch source<a href="#creating-a-dispatch-source" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>In order to create a GCD dispatch queue responsive to an event, the function <code>dispatch_source_create</code> must be used to create a dispatch source. Many different types of dispatch sources exist. However for our particular use-case, we are interested in the <code>DISPATCH_SOURCE_TYPE_MACH_RECV</code> dispatch queue type, however there are many other types, the following is a list of them:</p>
<ul>
<li>
<p><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>, <code>DISPATCH_SOURCE_TYPE_DATA_OR</code></p>
<p>Sources of this type allow applications to manually trigger the source&rsquo;s event handler via a
call to dispatch_source_merge_data().  The data will be merged with the source&rsquo;s pending
data via an atomic add or logic OR (based on the source&rsquo;s type), and the event handler block
will be submitted to the source&rsquo;s target queue.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_MACH_SEND</code></p>
<p>Sources of this type monitor a mach port with a send right for state changes.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_MACH_RECV</code></p>
<p>Sources of this type monitor a mach port with a receive right for state changes.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_PROC</code></p>
<p>Sources of this type monitor processes for state changes.  The handle is the process
identifier (pid_t) of the process to monitor and the mask may be one or more of the
following:</p>
<ul>
<li><code>DISPATCH_PROC_EXIT</code>    The process has exited and is available to wait(2).</li>
<li><code>DISPATCH_PROC_FORK</code>    The process has created one or more child processes.</li>
<li><code>DISPATCH_PROC_EXEC</code>    The process has become another executable image via a call to execve(2) or posix_spawn(2).</li>
<li><code>DISPATCH_PROC_REAP</code>    The process status has been collected by its parent process via wait(2).</li>
<li><code>DISPATCH_PROC_SIGNAL</code>  A signal was delivered to the process.</li>
</ul>
<p>The data returned by dispatch_source_get_data() indicates which of the events in the mask
were observed.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_READ</code></p>
<p>Sources of this type monitor file descriptors for pending data.  The handle is the file
descriptor (int) to monitor and the mask is unused and should be zero.</p>
<p>The data returned by dispatch_source_get_data() is an estimated number of bytes available to
be read from the descriptor.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_SIGNAL</code></p>
<p>Sources of this type monitor signals delivered to the current process. The handle is the
signal number to monitor (int) and the mask is unused and should be zero.</p>
<p>The data returned by dispatch_source_get_data() is the number of signals received since the
last invocation of the event handler block.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_TIMER</code></p>
<p>Sources of this type periodically submit the event handler block to the target queue on an
interval specified by dispatch_source_set_timer().  The handle and mask arguments are unused
and should be zero.</p>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_VNODE</code></p>
<p>Sources of this type monitor the virtual filesystem nodes for state changes.  The handle is
a file descriptor (int) referencing the node to monitor, and the mask may be one or more of
the following:</p>
<ul>
<li><code>DISPATCH_VNODE_DELETE</code>  The referenced node was removed from the filesystem namespace via unlink(2).</li>
<li><code>DISPATCH_VNODE_WRITE</code>   A write to the referenced file occurred</li>
<li><code>DISPATCH_VNODE_EXTEND</code>  The referenced file was extended</li>
<li><code>DISPATCH_VNODE_ATTRIB</code>  The metadata attributes of the referenced node have changed</li>
<li><code>DISPATCH_VNODE_LINK</code>    The link count on the referenced node has changed</li>
<li><code>DISPATCH_VNODE_RENAME</code>  The referenced node was renamed</li>
<li><code>DISPATCH_VNODE_REVOKE</code>  Access to the referenced node was revoked via revoke(2) or the underlying fileystem was unmounted.</li>
</ul>
</li>
<li>
<p><code>DISPATCH_SOURCE_TYPE_WRITE</code></p>
<p>Sources of this type monitor file descriptors for available write buffer space.  The handle
is the file descriptor (int) to monitor and the mask is unused and should be zero.</p>
</li>
</ul>
<p>As shown above by the different types of dispatch sources, dispatch sources are versatile and are convenient to distribute code on specific events on dedicated dispatch queues.</p>
<p>On our server, all we have to do to create a dispatch source to monitor state changes on a mach port is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  dispatch_source_t port_source <span style="color:#f92672">=</span> dispatch_source_create(
</span></span><span style="display:flex;"><span>    DISPATCH_SOURCE_TYPE_MACH_RECV,
</span></span><span style="display:flex;"><span>    recv_port,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    dispatch_queue_create(<span style="color:#e6db74">&#34;com.service.MessageQueue&#34;</span>, DISPATCH_QUEUE_CONCURRENT)
</span></span><span style="display:flex;"><span>  );</span></span></code></pre></div>
<h2 id="registering-an-event-handler-to-the-dispatch-source">Registering an event handler to the dispatch source<a href="#registering-an-event-handler-to-the-dispatch-source" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Once we have created our dispatch source, we can then register a handler to the dispatch source as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  dispatch_source_set_event_handler(port_source, <span style="color:#f92672">^</span>(<span style="color:#66d9ef">void</span>) { <span style="color:#75715e">/* code to handle incoming mach messages */</span> });</span></span></code></pre></div>
<h2 id="deploying-the-dispatch-queue">Deploying the dispatch queue<a href="#deploying-the-dispatch-queue" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Lasly, all we have to do left is to resume the dispatch source so the event handler to our dispatch queue gets deployed. We can do this as follows:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>dispatch_resume(port_source);</span></span></code></pre></div>
We can see that now when new incomming messages arrive, they will be processed in a dedicated concurrent queue:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#66d9ef">thread</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">2</span>, queue <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>com.service.MessageQueue<span style="color:#960050;background-color:#1e0010">&#39;</span>, stop reason <span style="color:#f92672">=</span> breakpoint <span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span>    frame <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0x0000000100003cdc</span> server<span style="color:#960050;background-color:#1e0010">`</span><span style="color:#a6e22e">__main_block_invoke</span>(.block_descriptor<span style="color:#f92672">=</span><span style="color:#ae81ff">0x00000001002043a0</span>) at server.mm:<span style="color:#ae81ff">63</span><span style="color:#f92672">:</span><span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">60</span>  
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">61</span>     <span style="color:#a6e22e">dispatch_source_set_event_handler</span>(port_source, <span style="color:#f92672">^</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">62</span>       ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mach_msg</span>(
</span></span><span style="display:flex;"><span><span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">63</span>           (<span style="color:#66d9ef">mach_msg_header_t</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>received_message,
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">64</span>           MACH_RCV_MSG,
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">65</span>           <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">66</span>           <span style="color:#66d9ef">sizeof</span> received_message,
</span></span><span style="display:flex;"><span>Target <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> (complex_port_client) stopped.
</span></span><span style="display:flex;"><span>(lldb)</span></span></code></pre></div>
<h1 id="ool-complex-message-example">OOL Complex Message Example<a href="#ool-complex-message-example" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The following example extends the previous example to support OOL messages. Is very similar to complex messages with port descriptors as we will see. For sake of simplicity the relevant part has been implemented in the server, although the code for the client will be also provided for testing purposes. Following is the source of the server:</p>
<h2 id="server-2">Server<a href="#server-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// server.mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;dispatch/dispatch.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  MachMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_ool_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} OOLMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  mach_port_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_name_t recv_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>recv_port) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_insert_right(
</span></span><span style="display:flex;"><span>          task, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  dispatch_source_t port_source <span style="color:#f92672">=</span> dispatch_source_create(
</span></span><span style="display:flex;"><span>    DISPATCH_SOURCE_TYPE_MACH_RECV,
</span></span><span style="display:flex;"><span>    recv_port,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    dispatch_queue_create(<span style="color:#e6db74">&#34;com.service.MessageQueue&#34;</span>, DISPATCH_QUEUE_CONCURRENT)
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (bootstrap_register(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, recv_port) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ool_buffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  vm_size_t ool_buffer_size <span style="color:#f92672">=</span> vm_page_size;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (vm_allocate(
</span></span><span style="display:flex;"><span>          mach_task_self(),
</span></span><span style="display:flex;"><span>          (vm_address_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>ool_buffer,
</span></span><span style="display:flex;"><span>          ool_buffer_size,
</span></span><span style="display:flex;"><span>          VM_PROT_READ <span style="color:#f92672">|</span> VM_PROT_WRITE) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;[-] Failed to allocate memory&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)ool_buffer, <span style="color:#e6db74">&#34;This is some OOL Data!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  dispatch_source_set_event_handler(port_source, <span style="color:#f92672">^</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ReceivedMachMessage received_message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>      (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>received_message,
</span></span><span style="display:flex;"><span>      MACH_RCV_MSG,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">sizeof</span> received_message,
</span></span><span style="display:flex;"><span>      recv_port,
</span></span><span style="display:flex;"><span>      MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>      MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      puts(<span style="color:#e6db74">&#34;[-] Could not receive mach message&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;[+] Got incoming message!&#34;</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">body: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, received_message.message.body);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    OOLMachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>      MACH_MSG_TYPE_COPY_SEND,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      MACH_MSGH_BITS_COMPLEX);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    message.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.header.msgh_remote_port;
</span></span><span style="display:flex;"><span>    message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    message.msgh_descriptor_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    message.descriptor.address <span style="color:#f92672">=</span> ool_buffer;
</span></span><span style="display:flex;"><span>    message.descriptor.size <span style="color:#f92672">=</span> ool_buffer_size;
</span></span><span style="display:flex;"><span>    message.descriptor.copy <span style="color:#f92672">=</span> MACH_MSG_VIRTUAL_COPY;
</span></span><span style="display:flex;"><span>    message.descriptor.deallocate <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    message.descriptor.type <span style="color:#f92672">=</span> MACH_MSG_OOL_DESCRIPTOR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>        (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,
</span></span><span style="display:flex;"><span>        MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">sizeof</span> message,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        MACH_PORT_NULL,
</span></span><span style="display:flex;"><span>        MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>        MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>      puts(<span style="color:#e6db74">&#34;[-] Could not send mach message reply&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  dispatch_resume(port_source);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  sleep(<span style="color:#ae81ff">120</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="allocating-ool-buffer">Allocating OOL Buffer<a href="#allocating-ool-buffer" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>One important thing to highlight is that in order to send an OOL message, we need to first allocate the OOL buffer we will be sending to our client. We could use any standard APIs to do this (such as malloc),  However, in our example we will be using <code>vm_allocate</code> to directly allocate virtual memory.</p>
<p>Here we allocate a new memory region of a page size, with read/write permissions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ool_buffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  vm_size_t ool_buffer_size <span style="color:#f92672">=</span> vm_page_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (vm_allocate(
</span></span><span style="display:flex;"><span>          mach_task_self(),
</span></span><span style="display:flex;"><span>          (vm_address_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>ool_buffer,
</span></span><span style="display:flex;"><span>          ool_buffer_size,
</span></span><span style="display:flex;"><span>          VM_PROT_READ <span style="color:#f92672">|</span> VM_PROT_WRITE) <span style="color:#f92672">!=</span> KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;[-] Failed to allocate memory&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)ool_buffer, <span style="color:#e6db74">&#34;This is some OOL Data!&#34;</span>);</span></span></code></pre></div>
<h3 id="setting-appropiate-ool-message-msgh_bits">Setting appropiate OOL Message MSGH_BITS<a href="#setting-appropiate-ool-message-msgh_bits" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Lets remember that we have to set the appropiate bit in <code>msgh_bits</code> field in our mach message header to direct that our message is a complex message setting the <code>MACH_MSGH_BITS_COMPLEX</code> bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>OOLMachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_MSGH_BITS_COMPLEX);</span></span></code></pre></div>
<h3 id="crafting-an-ool-message">Crafting an OOL Message<a href="#crafting-an-ool-message" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>The type definition for our OOL Mach message is the following:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_ool_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} OOLMachMessage;</span></span></code></pre></div>
We can notice that a new descriptor type is introduced, which is of type <code>mach_msg_ool_descriptor_t</code>.
The following is the OOL descriptor structure:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>                         address;
</span></span><span style="display:flex;"><span>  mach_msg_size_t               size;
</span></span><span style="display:flex;"><span>  boolean_t                     deallocate: <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  mach_msg_copy_options_t       copy: <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>                  pad1: <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  mach_msg_descriptor_type_t    type: <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>} mach_msg_ool_descriptor_t;</span></span></code></pre></div>
The fields of this descriptor are:</p>
<ul>
<li><code>address</code>: the out-of-line data</li>
<li><code>size</code>: size of the ool data</li>
<li><code>deallocate</code>: true if the memory page at the address wants to be removed from the senderâ€™s address space once the messageâ€™s been sent</li>
<li><code>copy</code>: defines the way of copying the memory</li>
<li><code>type</code>: defines the type of the message descriptor, for the OOL descriptor, itâ€™s <code>MACH_MSG_OOL_DESCRIPTOR</code></li>
</ul>
<p>In addition, there are two copy types, these are:</p>
<ul>
<li>
<p><code>MACH_MSG_VIRTUAL_COPY</code>
When sending a message, the kernel can choose how to
exactly transmit data. For example, it can decide to actually copy physical
memory, or make a virtual copy.</p>
<p>When receiving this means that the kernel made a virtual copy.</p>
</li>
<li>
<p><code>MACH_MSG_PHYSICAL_COPY</code>
When sending a message, this option instructs the kernel
to perform an actual copy of the physical memory.</p>
</li>
</ul>
<p>On the receiving end, this means there&rsquo;s a new physical copy of the memory.
For the scope of this article, youâ€™re only going to need the <code>MACH_MSG_VIRTUAL_COPY</code> copy type.</p>
<p>Note that sending out-of-line data requires merely the data address and size, where both can be dynamic. This is unlike inline data, where indirection isnâ€™t possible, and all data must be copied into the message buffer.</p>
<p>The following is how we populate the OOL message structures in our server:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    message.header.msgh_remote_port <span style="color:#f92672">=</span> received_message.message.header.msgh_remote_port;
</span></span><span style="display:flex;"><span>    message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    message.msgh_descriptor_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    message.descriptor.address <span style="color:#f92672">=</span> ool_buffer;
</span></span><span style="display:flex;"><span>    message.descriptor.size <span style="color:#f92672">=</span> ool_buffer_size;
</span></span><span style="display:flex;"><span>    message.descriptor.copy <span style="color:#f92672">=</span> MACH_MSG_VIRTUAL_COPY;
</span></span><span style="display:flex;"><span>    message.descriptor.deallocate <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    message.descriptor.type <span style="color:#f92672">=</span> MACH_MSG_OOL_DESCRIPTOR;</span></span></code></pre></div>
After this, all there is left is to send the message to the client.</p>
<h2 id="client-2">Client<a href="#client-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The client does not introduce any new changes to handle OOL messages in addition to what has been already introduced in the server. For sake of convenience the client source code is left here for testing:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// client.mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bootstrap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_init.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/message.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/port.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/task.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/mach_vm.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/vm_map.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach/vm_region.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> body[<span style="color:#ae81ff">4096</span>];
</span></span><span style="display:flex;"><span>} MachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  mach_msg_header_t header;
</span></span><span style="display:flex;"><span>  mach_msg_size_t msgh_descriptor_count;
</span></span><span style="display:flex;"><span>  mach_msg_ool_descriptor_t descriptor;
</span></span><span style="display:flex;"><span>} OOLMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  OOLMessage message;
</span></span><span style="display:flex;"><span>  mach_msg_trailer_t trailer;
</span></span><span style="display:flex;"><span>} ReceivedOOLMachMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    mach_port_name_t task <span style="color:#f92672">=</span> mach_task_self();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t bootstrap_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task_get_special_port(task, TASK_BOOTSTRAP_PORT, <span style="color:#f92672">&amp;</span>bootstrap_port) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (bootstrap_look_up(bootstrap_port, <span style="color:#e6db74">&#34;com.service.alice&#34;</span>, <span style="color:#f92672">&amp;</span>port) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_port_t reply_port;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, <span style="color:#f92672">&amp;</span>reply_port) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mach_port_insert_right(
</span></span><span style="display:flex;"><span>          task, reply_port, reply_port, MACH_MSG_TYPE_MAKE_SEND) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>      KERN_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  MachMessage message <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  message.header.msgh_remote_port <span style="color:#f92672">=</span> port;
</span></span><span style="display:flex;"><span>  message.header.msgh_local_port <span style="color:#f92672">=</span> reply_port;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  message.header.msgh_bits <span style="color:#f92672">=</span> MACH_MSGH_BITS_SET(
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_COPY_SEND,
</span></span><span style="display:flex;"><span>    MACH_MSG_TYPE_MAKE_SEND,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  message.header.msgh_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span> message ;
</span></span><span style="display:flex;"><span>  strcpy(message.body, <span style="color:#e6db74">&#34;A sample message&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mach_msg_return_t ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>message,
</span></span><span style="display:flex;"><span>    MACH_SEND_MSG,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> message,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ReceivedOOLMachMessage response <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> mach_msg(
</span></span><span style="display:flex;"><span>    (mach_msg_header_t <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>response,
</span></span><span style="display:flex;"><span>    MACH_RCV_MSG,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">sizeof</span> response,
</span></span><span style="display:flex;"><span>    reply_port,
</span></span><span style="display:flex;"><span>    MACH_MSG_TIMEOUT_NONE,
</span></span><span style="display:flex;"><span>    MACH_PORT_NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> MACH_MSG_SUCCESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;[+] Received OOL messge!</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">buffer: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)response.message.descriptor.address
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div># References
I want to show my special gratitude to Damian Malarczyk, as the content of this post was derived from his series on XNU IPC.</p>
<ol>
<li><a href="https://dmcyk.xyz">Damian Malarczyk</a></li>
<li><a href="http://newosxbook.com/">macOS and *OS Internals</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html">Mach Overview</a></li>
<li><a href="https://www.gnu.org/software/hurd/gnumach-doc/Exchanging-Port-Rights.html">Exchanging port rights</a></li>
<li><a href="https://docs.darlinghq.org/internals/macos-specifics/mach-ports.html">About Mach Ports</a></li>
<li><a href="https://blog.wuntee.sexy/reaching-the-mach-layer">Reaching the mach layer</a></li>
</ol>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Ignacio Sanmillan</span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
