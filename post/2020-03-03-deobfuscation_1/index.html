<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Tales Of Binary Deobfuscation :: ulexec.github.io</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="This article is going to serve as my personal reference on this topic. Since I&amp;rsquo;ve always wanted to write about it and just finished Yuma Kurogome&amp;rsquo;s course on Advance Binary Deobfuscation, I thought it would be a good time to write notes regarding what I learned in this course with a fresh state of mind on the subject matter for future reference.
Introduction There are close to 31 known code transformations." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://ulexec.github.io/post/2020-03-03-deobfuscation_1/" />






  
  
  
  
  
  <link rel="stylesheet" href="https://ulexec.github.io/styles.css">







  <link rel="shortcut icon" href="https://ulexec.github.io/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="https://ulexec.github.io/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Tales Of Binary Deobfuscation">
<meta property="og:description" content="This article is going to serve as my personal reference on this topic. Since I&amp;rsquo;ve always wanted to write about it and just finished Yuma Kurogome&amp;rsquo;s course on Advance Binary Deobfuscation, I thought it would be a good time to write notes regarding what I learned in this course with a fresh state of mind on the subject matter for future reference.
Introduction There are close to 31 known code transformations." />
<meta property="og:url" content="https://ulexec.github.io/post/2020-03-03-deobfuscation_1/" />
<meta property="og:site_name" content="ulexec.github.io" />

  
    <meta property="og:image" content="https://ulexec.github.io/img/favicon/orange.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="writeup" />


  <meta property="article:published_time" content="2020-03-03 00:00:00 &#43;0000 UTC" />












</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/post/">
  <div class="logo">
    ulexec.github.io
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;â–¾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/post/">Posts</a></li>
        
      
        
          <li><a href="/publications/">Publications</a></li>
        
      
        
          <li><a href="/projects/">Projects</a></li>
        
      
        
          <li><a href="/advisories/">Advisories</a></li>
        
      
        
          <li><a href="/about/">About</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/post/" >Posts</a></li>
        
      
        
          <li><a href="/publications/" >Publications</a></li>
        
      
        
          <li><a href="/projects/" >Projects</a></li>
        
      
        
          <li><a href="/advisories/" >Advisories</a></li>
        
      
        
          <li><a href="/about/" >About</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://ulexec.github.io/post/2020-03-03-deobfuscation_1/">Tales Of Binary Deobfuscation</a>
  </h1>
  <div class="post-meta"><time class="post-date">2020-03-03</time><span class="post-author">ulexec</span></div>

  
    <span class="post-tags">
      
      #<a href="https://ulexec.github.io/tags/reversing/">reversing</a>&nbsp;
      
      #<a href="https://ulexec.github.io/tags/malware/">malware</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <p>This article is going to serve as my personal reference on this topic. Since I&rsquo;ve always wanted to write about it and just finished Yuma Kurogome&rsquo;s course on <a href="https://github.com/malrev/ABD">Advance Binary Deobfuscation</a>, I thought it would be a good time to write notes regarding what I learned in this course with a fresh state of mind on the subject matter for future reference.</p>
<h2 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>There are close to 31 known <a href="https://mediatum.ub.tum.de/doc/1367533/1367533.pdf">code transformations</a>. However, In this article we will focus on grouping these transformation in categories based on their behavior, and we will cover some of the most relevant techniques today on a conceptual point of view.
We will be also covering practical approaches to the aforementioned techniques using the reverse engineering framework MIASM (0.1.3.dev39).</p>
<p>Despite the large number of transformations, obfuscation techniques can be group up into 3 different categories:</p>
<ul>
<li>Confusion oriented:
<ul>
<li>Unreachable Code Insertion</li>
<li>Dead Code Insertion</li>
</ul>
</li>
<li>Syntax Modification
<ul>
<li>Instruction Substitution</li>
<li>Constant Folding/Unfolding</li>
</ul>
</li>
<li>Semantic Modification
<ul>
<li>Opaque Predicates</li>
<li>Range Dividers</li>
<li>Virtualization</li>
<li>Control Flow Flattening</li>
</ul>
</li>
</ul>
<p>We will be discussing each of these techniques on a conceptual level, although we will be also covering practical examples.
The purpose of this article is to crystallize concepts instead of being a strict technical reference, although further technical reading will be linked all throughout the article along with practical implementations on how to remediate some of these techniques.</p>
<!-- raw HTML omitted -->
<p>In this section we will be covering 3 different transformations which have a close correlation between one another, and consequently a similar approach for circumvention.</p>
<ul>
<li>
<p><strong>Unreachable Code</strong>: is defined as inserted code into a target application which is never going to be executed, serving the purpose of an unexpensive way of distracting the analyst for a few minutes.
an example of Junk code is the following:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">jz</span> loc_key1      <span style="color:#75715e">; lets imagine this conditional branch is not really conditional</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">xor</span> eax, eax     <span style="color:#75715e">; * this will never execute</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pushf</span> 	         <span style="color:#75715e">; *</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pop</span> ebx          <span style="color:#75715e">; *</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">and</span> ebx, <span style="color:#ae81ff">0x100</span>   <span style="color:#75715e">; *</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">cmp</span> ebx, <span style="color:#ae81ff">0x100</span>   <span style="color:#75715e">; *</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">je</span> loc_key2      <span style="color:#75715e">; *</span>
</span></span><span style="display:flex;"><span>loc_key1:</span></span></code></pre></div><!-- raw HTML omitted --></p>
</li>
<li>
<p><strong>Dead Code</strong>: is defined as inserted code into a target application which, although it may be executed, it does not change the original control flow of the program.
Again this technique&rsquo;s pupose is to just confuse the analyst to make him/her spend a bit more time understanding the purpose of the aforementioned instructions.
The following is an example:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">0xdeadc00d</span>  <span style="color:#75715e">; * this specific instruction is deadcode</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, [ebp<span style="color:#f92672">+</span>arg_4]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> ecx, [ebp<span style="color:#f92672">+</span>arg_0]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">5</span>           <span style="color:#75715e">; * edx gets overriden here, also deadcode</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> [ebp<span style="color:#f92672">+</span>var_4], ecx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> [ebp<span style="color:#f92672">+</span>var_8], eax</span></span></code></pre></div><!-- raw HTML omitted --></p>
</li>
<li>
<p><strong>Instruction Substitution</strong>: defined as to replace a given set of instructions with another more complex set of instructions with identical semantic meaning. This kind of techniques have been heavely employed by metamorphic code engines in the past and may highly affect the legibility of the affected code.
Lets imagine that originally we have the following set of instructions:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, [ebp<span style="color:#f92672">+</span>var_8]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> eax, [ebp<span style="color:#f92672">+</span>var_C]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> eax, [ebp<span style="color:#f92672">+</span>var_10]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> eax, [ebp<span style="color:#f92672">+</span>var_4]</span></span></code></pre></div>This set of instruction can be transform to the following one, being much harder to interpret and understand having the same semantic meaning:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, [ebp<span style="color:#f92672">+</span>var_C]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> edx, [ebp<span style="color:#f92672">+</span>var_10]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> eax, <span style="color:#ae81ff">2598A32Bh</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> eax, edx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> eax, <span style="color:#ae81ff">2598A32Bh</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> edx, [ebp<span style="color:#f92672">+</span>var_4]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> esi, ecx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> esi, eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, ecx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> eax, edx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> esi, eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, ecx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> eax, esi
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> edx,[ebp<span style="color:#f92672">+</span>var_8]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> ecx, edx
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> eax, ecx</span></span></code></pre></div><!-- raw HTML omitted --></p>
</li>
</ul>
<h3 id="circumvention">Circumvention<a href="#circumvention" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>In order to mitigate these transformations we can do a variety of techniques based on Data Flow Analysis. Before we introduce these techniques, is important to understand that in order to succesfully implement Data Flow Analysis strategies we have to rely on a Intermediate Representation of the subject code. Compilers also rely on IRs to apply their program synthesis and code optimitations capabilities. In other words, We can deobfuscate these transformations by using the same techniques used by compilers for
their own optimization purposes.</p>
<p>These techniques are the following:</p>
<!-- raw HTML omitted -->
<h4 id="reachable-definition-analysis">Reachable Definition Analysis<a href="#reachable-definition-analysis" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ul>
<li>Forward dataflow analysis</li>
<li>Analyze where the value of each variable was defined when a certain point in the program was reached</li>
<li>Application:
<ul>
<li>Constant propagation/folding</li>
<li>Transform expressions</li>
</ul>
</li>
</ul>
<p>An overview of how Reachability Analysis work can be shown in the following picture from Yuma&rsquo;s Course:
<img src="/Reachability_Analysis.png#center" alt=""></p>
<!-- raw HTML omitted -->
<h4 id="liveless-analysis">Liveless Analysis<a href="#liveless-analysis" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ul>
<li>Backward dataflow analysis</li>
<li>Analyze whether the value x in the program point p may be used when following the edge starting from p in the flow graph with respect to x</li>
<li>Application:
<ul>
<li>Dead code elimination</li>
</ul>
</li>
</ul>
<p>An overview of how Liveless Analysis work can be shown in the following picture from Yuma&rsquo;s Course:
<!-- raw HTML omitted --></p>
<p><img src="/Liveless_Analysis.png#center" alt=""></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Both reachable definition analysis and liveness analysis are IR optimization techniques used by a compiler backend, and are also useful for binary analysis.</p>
<!-- raw HTML omitted -->
<h4 id="practical-example-deobfuscating-ollvms-instruction-substitution-pass">Practical Example. Deobfuscating OLLVM&rsquo;s Instruction Substitution Pass<a href="#practical-example-deobfuscating-ollvms-instruction-substitution-pass" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>For this example we will be using the given example compiled with o-llvm -sub flag to enable OLLVM&rsquo;s Intruction Substitution Pass.</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">target_function</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a,b,c,r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>    b <span style="color:#f92672">=</span> <span style="color:#ae81ff">56</span>;
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> <span style="color:#ae81ff">127</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#a6e22e">target_function</span>(argc);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;n=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>Both target_functions before and after obfuscation look like this:</p>
<p><img src="/inst_sub_r2.png#center" alt="">
<!-- raw HTML omitted --></p>
<p>Since we need a framework to lift the code to an IR to apply these types of optimization analyses, we can use MIASM&rsquo;s Data Flow Analysis modules to deobfuscate transformations such as instruction substitution, dead/junk code or constant unfolding.</p>
<p>MIASM has a simple way of retrieving and lifting the subject function to MIASM IR:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Opening Target File and Storing it in a &#39;Container&#39; Object</span>
</span></span><span style="display:flex;"><span>cont <span style="color:#f92672">=</span> Container<span style="color:#f92672">.</span>from_stream(open(args<span style="color:#f92672">.</span>target, <span style="color:#e6db74">&#39;rb&#39;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Instantiating disassembler</span>
</span></span><span style="display:flex;"><span>machine <span style="color:#f92672">=</span> Machine(args<span style="color:#f92672">.</span>architecture <span style="color:#66d9ef">if</span> args<span style="color:#f92672">.</span>architecture <span style="color:#66d9ef">else</span> cont<span style="color:#f92672">.</span>arch)
</span></span><span style="display:flex;"><span>dis <span style="color:#f92672">=</span> machine<span style="color:#f92672">.</span>dis_engine(cont<span style="color:#f92672">.</span>bin_stream, loc_db<span style="color:#f92672">=</span>cont<span style="color:#f92672">.</span>loc_db)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Disassembling and Extracting CFG</span>
</span></span><span style="display:flex;"><span>asmcfg <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span>dis_multiblock(int(args<span style="color:#f92672">.</span>addr, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Extracting IR archive and IRCFG</span>
</span></span><span style="display:flex;"><span>ir_arch <span style="color:#f92672">=</span> machine<span style="color:#f92672">.</span>ira(cont<span style="color:#f92672">.</span>loc_db)
</span></span><span style="display:flex;"><span>ircfg <span style="color:#f92672">=</span> ir_arch<span style="color:#f92672">.</span>new_ircfg_from_asmcfg(asmcfg)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Simplifying IR</span>
</span></span><span style="display:flex;"><span>deadrm <span style="color:#f92672">=</span> DeadRemoval(ir_arch)
</span></span><span style="display:flex;"><span>entry_points <span style="color:#f92672">=</span> set([dis<span style="color:#f92672">.</span>loc_db<span style="color:#f92672">.</span>get_offset_location(args<span style="color:#f92672">.</span>addr)])
</span></span><span style="display:flex;"><span>init_infos <span style="color:#f92672">=</span> ir_arch<span style="color:#f92672">.</span>arch<span style="color:#f92672">.</span>regs<span style="color:#f92672">.</span>regs_init
</span></span><span style="display:flex;"><span>cst_propag_link <span style="color:#f92672">=</span> propagate_cst_expr(ir_arch, ircfg, args<span style="color:#f92672">.</span>addr, init_infos)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># deadrm(ircfg)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># remove_empty_assignblks(ircfg)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This line simplifies the IR with the same features as above and more</span>
</span></span><span style="display:flex;"><span>ircfg<span style="color:#f92672">.</span>simplify(expr_simp_high_to_explicit)</span></span></code></pre></div>
At this point we will be able to optimise the given subject function and consequently mitigate the aforementioned obfuscation techniques. In order to show the result in a more readable format, it would be nice to transform the optimized IR function representation back to x86, the original architecture we compiled our test case.
Unfortunatelly, MIASM&rsquo;s IR is not backwards compatible with x86, however MIASM provide capabilities to translate MIASM&rsquo;s IR to LLVM IR to then retrieve back the optimized subject function in its native representation.</p>
<p>In order to do this we can do the following:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Instantiate an LLVM context and Function to fill</span>
</span></span><span style="display:flex;"><span>context <span style="color:#f92672">=</span> LLVMContext_IRCompilation()
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>ir_arch <span style="color:#f92672">=</span> ir_arch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func <span style="color:#f92672">=</span> LLVMFunction_IRCompilation(context, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>func<span style="color:#f92672">.</span>ret_type <span style="color:#f92672">=</span> llvm_ir<span style="color:#f92672">.</span>VoidType()
</span></span><span style="display:flex;"><span>func<span style="color:#f92672">.</span>init_fc()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># IRCFG is imported, without the final &#34;ret void&#34;</span>
</span></span><span style="display:flex;"><span>func<span style="color:#f92672">.</span>from_ircfg(ircfg, append_ret<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Finish the function</span>
</span></span><span style="display:flex;"><span>func<span style="color:#f92672">.</span>builder<span style="color:#f92672">.</span>ret_void()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Parsing LLVM IR</span>
</span></span><span style="display:flex;"><span>M <span style="color:#f92672">=</span> llvm<span style="color:#f92672">.</span>parse_assembly(str(func))
</span></span><span style="display:flex;"><span>M<span style="color:#f92672">.</span>verify()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initialising Native Exporter</span>
</span></span><span style="display:flex;"><span>llvm<span style="color:#f92672">.</span>initialize()
</span></span><span style="display:flex;"><span>llvm<span style="color:#f92672">.</span>initialize_native_target()
</span></span><span style="display:flex;"><span>llvm<span style="color:#f92672">.</span>initialize_native_asmprinter()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Optimisation to clean value computation</span>
</span></span><span style="display:flex;"><span>pmb <span style="color:#f92672">=</span> llvm<span style="color:#f92672">.</span>create_pass_manager_builder()
</span></span><span style="display:flex;"><span>pmb<span style="color:#f92672">.</span>opt_level <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>pm <span style="color:#f92672">=</span> llvm<span style="color:#f92672">.</span>create_module_pass_manager()
</span></span><span style="display:flex;"><span>pmb<span style="color:#f92672">.</span>populate(pm)
</span></span><span style="display:flex;"><span>pm<span style="color:#f92672">.</span>run(M)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate Binary output</span>
</span></span><span style="display:flex;"><span>target <span style="color:#f92672">=</span> llvm<span style="color:#f92672">.</span>Target<span style="color:#f92672">.</span>from_default_triple()
</span></span><span style="display:flex;"><span>target <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span>from_triple(<span style="color:#e6db74">&#39;i386-pc-linux-gnu&#39;</span>)
</span></span><span style="display:flex;"><span>target_machine <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span>create_target_machine()
</span></span><span style="display:flex;"><span>obj_bin <span style="color:#f92672">=</span> target_machine<span style="color:#f92672">.</span>emit_object(M)
</span></span><span style="display:flex;"><span>obj <span style="color:#f92672">=</span> llvm<span style="color:#f92672">.</span>ObjectFileRef<span style="color:#f92672">.</span>from_data(obj_bin)
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#34;./</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">-</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">.o&#34;</span> <span style="color:#f92672">%</span> (args<span style="color:#f92672">.</span>target, hex(int(args<span style="color:#f92672">.</span>addr, <span style="color:#ae81ff">0</span>))), <span style="color:#e6db74">&#34;wb&#34;</span>)<span style="color:#f92672">.</span>write(obj_bin)</span></span></code></pre></div>The full script can be downloaded <a href="https://github.com/ulexec/ulexec.github.io/raw/master/files/optimize.py">here</a></p>
<p>After running the previous script, we will see it will generate an ET_REL type ELF file containing the native version of our deobfuscated function by optimization.
The following is the result of this:</p>
<p><img src="/deobfuscated_func.png#center" alt="">
<!-- raw HTML omitted --></p>
<p>As we can see in the previous screenshot, there is some dead code resident in the optimized function. This dead code represents the local variables used in the obfuscated (and original) version of the function.</p>
<p>Data Flow Analysis and optimizations are restricted to memory writes along with other constraints such as variables involved in conditional jumps.
Despite this, we can clearly see that Data Flow Analysis can be very effective for instruction subtitution deobfuscation giving us a simplified version of what the function may have looked like after and even before obfuscation.</p>
<p>As we mentioned there are some additional contraints while removing some of the dead code after simplification, such as memory writes or variables needed for conditional branches. In regards to conditional branches, in the next section we will cover the concept of opaque predicates and what we can do to indentify and mitigate them.</p>
<!-- raw HTML omitted -->
<h2 id="opaque-predicates">Opaque Predicates<a href="#opaque-predicates" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Opaque predicates in a nutshell is a commonly used technique in code obfuscation intended to add complexity to control flow usually implemented as conditional branches although these conditional branches have a deterministic control flow.</p>
<p>A simple example of what opaque predicates are can be shown in the following C code:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span> (<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, b<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(a <span style="color:#f92672">==</span> b) {        <span style="color:#75715e">// opaque predicate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;This is never going to execute&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;predifined control flow&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;		
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
The previous C snippet is an over-simplified opaque predicate example, however its important to illustrate the concept we are trying to tackle. As we can see in the  example, a and b local variables are never going to satisfy the equality condition of the if statement since the values of a and b are not dependant on function&rsquo;s input, therefore the condition itself is not prone to change.</p>
<p>This same concept can be extrapolated to more complex equalities/conditions usually appearing in high volume on a subject obfuscated application.
Depending on the implementation sophistication of this technique, control flow clarity can be highly affected and therefore the interpretation and time of analysis of a subject application.</p>
<!-- raw HTML omitted -->
<h3 id="circumvention-1">Circumvention<a href="#circumvention-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>One approach to identify opaque predicates is to use Symbolic Execution along with an SMT solver in order to check feasibility on conditional branches.</p>
<p>How it works:</p>
<ul>
<li>Execute a program sequentially while treating input values as symbols that represent all possible values.</li>
<li>Add constraints on symbols.
<ul>
<li>Path Constraint: Constraints to execute a path.</li>
<li>Symbolic Store: Updated symbol information.</li>
</ul>
</li>
<li>When the target address of the conditional jump is reached, solve the constraints with a SMT solver and get a concrete input value.
<ul>
<li>Need to convert IR to SMT solver-acceptable expressions.</li>
</ul>
</li>
</ul>
<p>Opaque predicates have a deterministic feasibility regardless of input values.
Therefore, we can invoke a SMT solver at every conditional branch and verify whether there is an input value that evaluates the condition to a True or False result.
If a subject conditional branch is not dependant on a input value the branch should be an opaque predicate.
We can apply the technique discussed above and attempt to detect opaque predicates via Symbolic Execution + SMT solver.</p>
<!-- raw HTML omitted -->
<h4 id="practical-example-deobfuscating-x-tunnel-opaque-predicates">Practical Example. Deobfuscating X-Tunnel Opaque Predicates<a href="#practical-example-deobfuscating-x-tunnel-opaque-predicates" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>The binary file we are going to use for this example is the following:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>X<span style="color:#f92672">-</span>Tunnel: a979c5094f75548043a22b174aa10e1f2025371bd9e1249679f052b168e194b3</span></span></code></pre></div>
The first thing we have to do is to write a path exploration function based on Symbolic Execution.
We can do this with MIASM as follows:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">explore</span>(ir, start_addr, start_symbols,
</span></span><span style="display:flex;"><span>        ircfg, cond_limit<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>, uncond_limit<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>,
</span></span><span style="display:flex;"><span>        lbl_stop<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, final_states<span style="color:#f92672">=</span>[]):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">codepath_walk</span>(addr, symbols, conds, depth, final_states, path):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Instantiate MIASM Symbolic Execution Engine</span>
</span></span><span style="display:flex;"><span>        sb <span style="color:#f92672">=</span> SymbolicExecutionEngine(ir, symbols)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(uncond_limit):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> isinstance(addr, ExprInt):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># recursion delimiter</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> addr<span style="color:#f92672">.</span>_get_int() <span style="color:#f92672">==</span> lbl_stop:
</span></span><span style="display:flex;"><span>                    final_states<span style="color:#f92672">.</span>append(FinalState(<span style="color:#66d9ef">True</span>, sb, conds, path))
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Append all executed Paths</span>
</span></span><span style="display:flex;"><span>            path<span style="color:#f92672">.</span>append(addr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Run Symbolic Engine at block</span>
</span></span><span style="display:flex;"><span>            pc <span style="color:#f92672">=</span> sb<span style="color:#f92672">.</span>run_block_at(ircfg, addr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># if IR expression is a condition</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> isinstance(pc, ExprCond):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Create conditions that satisfy true or false paths</span>
</span></span><span style="display:flex;"><span>                cond_true  <span style="color:#f92672">=</span> {pc<span style="color:#f92672">.</span>cond: ExprInt(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">32</span>)}
</span></span><span style="display:flex;"><span>                cond_false <span style="color:#f92672">=</span> {pc<span style="color:#f92672">.</span>cond: ExprInt(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">32</span>)}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Compute the destination addr of the true or false paths</span>
</span></span><span style="display:flex;"><span>                addr_true  <span style="color:#f92672">=</span> expr_simp(
</span></span><span style="display:flex;"><span>                    sb<span style="color:#f92672">.</span>eval_expr(pc<span style="color:#f92672">.</span>replace_expr(cond_true), {}))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                addr_false <span style="color:#f92672">=</span> expr_simp(
</span></span><span style="display:flex;"><span>                    sb<span style="color:#f92672">.</span>eval_expr(pc<span style="color:#f92672">.</span>replace_expr(cond_false), {}))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Adding previous conditions of previous</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># blocks in path to satisfy reachability of current block</span>
</span></span><span style="display:flex;"><span>                conds_true <span style="color:#f92672">=</span> list(conds) <span style="color:#f92672">+</span> list(cond_true<span style="color:#f92672">.</span>items())
</span></span><span style="display:flex;"><span>                conds_false <span style="color:#f92672">=</span> list(conds) <span style="color:#f92672">+</span> list(cond_false<span style="color:#f92672">.</span>items())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Check feasibility of True condition on conditional branch</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> check_path_feasibility(conds_true):
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If True path is feasible, continue with Symbolic Execution</span>
</span></span><span style="display:flex;"><span>                    codepath_walk(
</span></span><span style="display:flex;"><span>                        addr_true, sb<span style="color:#f92672">.</span>symbols<span style="color:#f92672">.</span>copy(),
</span></span><span style="display:flex;"><span>                        conds_true, depth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, final_states, list(path))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If not, store the current block and stop recursion</span>
</span></span><span style="display:flex;"><span>                    final_states<span style="color:#f92672">.</span>append(FinalState(<span style="color:#66d9ef">False</span>, sb, conds_true, path))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> check_path_feasibility(conds_false):
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If False path is feasible, continue with Symbolic Execution</span>
</span></span><span style="display:flex;"><span>                    codepath_walk(
</span></span><span style="display:flex;"><span>                        addr_false, sb<span style="color:#f92672">.</span>symbols<span style="color:#f92672">.</span>copy(),
</span></span><span style="display:flex;"><span>                        conds_false, depth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, final_states, list(path))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If not, store the current block and stop recursion</span>
</span></span><span style="display:flex;"><span>                    final_states<span style="color:#f92672">.</span>append(FinalState(<span style="color:#66d9ef">False</span>, sb, conds_false, path))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># If current IR expression is not a Condition,</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># simplify block expresion</span>
</span></span><span style="display:flex;"><span>                addr <span style="color:#f92672">=</span> expr_simp(sb<span style="color:#f92672">.</span>eval_expr(pc))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Append Final state</span>
</span></span><span style="display:flex;"><span>        final_states<span style="color:#f92672">.</span>append(FinalState(<span style="color:#66d9ef">True</span>, sb, conds, path))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Start by walking function from its start address</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> codepath_walk(start_addr, start_symbols, [], <span style="color:#ae81ff">0</span>, final_states, [])</span></span></code></pre></div>
As seen in the previous snippet, the overall steps of our path exploration algorithm are the following:</p>
<ul>
<li>Symbolically Execute every block in current function until it finds a conditional IR expression (which would be the same as a conditional instruction in its native representation).</li>
<li>Once this conditional expression is reached, we then evaluate both the branch destination address if the condition would be satisfied and if it wouldn&rsquo;t accordingly.</li>
<li>When we have identified the two different branch addresses, then we compute the feasibility of each subject branch (which includes all previous conditions to reach to the designated destination address) and if its feasible we continue symbolically executing the branch. If not we mark that current path as finished and we store it.</li>
</ul>
<p>The feasibility of the branch condition can be done via MIASM&rsquo;s z3 SMT Solver Translator:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_path_feasibility</span>(conds):
</span></span><span style="display:flex;"><span>    solver <span style="color:#f92672">=</span> z3<span style="color:#f92672">.</span>Solver()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> lval, rval <span style="color:#f92672">in</span> conds:
</span></span><span style="display:flex;"><span>        z3_cond <span style="color:#f92672">=</span> Translator<span style="color:#f92672">.</span>to_language(<span style="color:#e6db74">&#34;z3&#34;</span>)<span style="color:#f92672">.</span>from_expr(lval)
</span></span><span style="display:flex;"><span>        solver<span style="color:#f92672">.</span>add(z3_cond <span style="color:#f92672">==</span> int(rval<span style="color:#f92672">.</span>arg))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rslt <span style="color:#f92672">=</span> solver<span style="color:#f92672">.</span>check()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> rslt <span style="color:#f92672">==</span> z3<span style="color:#f92672">.</span>sat:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span></span></span></code></pre></div>
After Symbolic Execution of our target function is done, we will have an array of all of the stored final states of each path in the function.
These final states will contained every executed block.
In order to identify blocks which have not been executed, we do the following:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The IR nodes in final_states array are the path nodes that were executed.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We collect the &#39;lock_key&#39; or block labels of each of the nodes executed</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> final_state <span style="color:#f92672">in</span> final_states:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> final_state<span style="color:#f92672">.</span>result:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> node <span style="color:#f92672">in</span> final_state<span style="color:#f92672">.</span>path_history:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> isinstance(node, int):
</span></span><span style="display:flex;"><span>                lbl <span style="color:#f92672">=</span> ircfg<span style="color:#f92672">.</span>get_loc_key(node)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> isinstance(node, ExprInt):
</span></span><span style="display:flex;"><span>                lbl <span style="color:#f92672">=</span> ircfg<span style="color:#f92672">.</span>get_loc_key(node<span style="color:#f92672">.</span>_get_int())
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> isinstance(node, LocKey):
</span></span><span style="display:flex;"><span>                lbl <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>loc_key
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> lbl <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> executed_lockey:
</span></span><span style="display:flex;"><span>                executed_lockey<span style="color:#f92672">.</span>append(lbl)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We then collect the non-executed blocks by comparing the executed ones</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with the totality of the blocks in the IRCFG</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> lbl, irblock <span style="color:#f92672">in</span> viewitems(ircfg<span style="color:#f92672">.</span>blocks):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lbl <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> executed_lockey:
</span></span><span style="display:flex;"><span>        unexecuted_lockey<span style="color:#f92672">.</span>append(lbl)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span></span></span></code></pre></div>
Once we have the locations of the blocks that haven&rsquo;t been executed, we can do a variety of things.
We could simply mark the non-executed blocks in order to inspect the target function for further analysis.
Yuma Kurogome shows how to do this in his course by dynamically creating an IDC script based on the context retrieved in previous stages:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">to_idc</span>(lockeys, asmcfg):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    header <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#include &lt;idc.idc&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static main(){
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    footer <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    body <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    f <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;op-color.idc&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> lbl <span style="color:#f92672">in</span> lockeys:
</span></span><span style="display:flex;"><span>        asmblk <span style="color:#f92672">=</span> asmcfg<span style="color:#f92672">.</span>loc_key_to_block(lbl)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> asmblk:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> asmblk<span style="color:#f92672">.</span>lines:
</span></span><span style="display:flex;"><span>                print(hex(l<span style="color:#f92672">.</span>offset))
</span></span><span style="display:flex;"><span>                body <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;SetColor(0x</span><span style="color:#e6db74">%08x</span><span style="color:#e6db74">, CIC_ITEM, 0xc7c7ff);</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">%</span>(l<span style="color:#f92672">.</span>offset)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(header<span style="color:#f92672">+</span>body<span style="color:#f92672">+</span>footer)
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>close()</span></span></code></pre></div>After applying this we can obtain the following results (function at 0x40A6A0):</p>
<p><img src="/x-tunnel_ops_detect.png#center" alt="">
<!-- raw HTML omitted --></p>
<p>This can help us to figure out the logic of the implementation of the subject opaque predicates. Once this is clear, we can then write a solution to patch the binary to obtain a more clear view of the function&rsquo;s control flow to apply further analysis to it such as optimizations or data flow analysis after opaque predicates are removed.
I decided to write a solution to remove X-Tunnel&rsquo;s opaque predicates by using radare2 via its r2pipe Python binding:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">remove_xtunnel_op</span>(lockeys, asmcfg):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Opening File in r2</span>
</span></span><span style="display:flex;"><span>    r2 <span style="color:#f92672">=</span> r2pipe<span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;./x-tunnel.bin&#34;</span>, [<span style="color:#e6db74">&#34;-w&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># applying reference analysis</span>
</span></span><span style="display:flex;"><span>    r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;aar&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># iterating for each block label</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> lbl <span style="color:#f92672">in</span> lockeys:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># retrieving block from label</span>
</span></span><span style="display:flex;"><span>        asmblk <span style="color:#f92672">=</span> asmcfg<span style="color:#f92672">.</span>loc_key_to_block(lbl)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> asmblk:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> asmblk<span style="color:#f92672">.</span>lines:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># seeking to address of instruction</span>
</span></span><span style="display:flex;"><span>                r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;s </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(l<span style="color:#f92672">.</span>offset))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># checking if there is any xrefs to</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># current instruction</span>
</span></span><span style="display:flex;"><span>                xref <span style="color:#f92672">=</span> r2<span style="color:#f92672">.</span>cmdj(<span style="color:#e6db74">&#34;axtj&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>  xref:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># retrieving the reference source address</span>
</span></span><span style="display:flex;"><span>                    xref_from <span style="color:#f92672">=</span> xref[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#39;from&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># retrieving the opcode</span>
</span></span><span style="display:flex;"><span>                    opcode <span style="color:#f92672">=</span> xref[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#39;opcode&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># seeking to reference source address</span>
</span></span><span style="display:flex;"><span>                    r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;s </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(xref_from))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># changing opcode for nop if its a je or a non</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># conditional jump if its any other branch instruction</span>
</span></span><span style="display:flex;"><span>                    r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;wao </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (<span style="color:#e6db74">&#34;nop&#34;</span> <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;je&#39;</span> <span style="color:#f92672">in</span> opcode <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;nocj&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># seek back to original block instrution</span>
</span></span><span style="display:flex;"><span>                r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;s </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(l<span style="color:#f92672">.</span>offset))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># patching instruction with a nop</span>
</span></span><span style="display:flex;"><span>                r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;wao nop&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># seeking to previous instruction</span>
</span></span><span style="display:flex;"><span>                r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;so -1&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># retrieving its opcode</span>
</span></span><span style="display:flex;"><span>                opcode <span style="color:#f92672">=</span> r2<span style="color:#f92672">.</span>cmdj(<span style="color:#e6db74">&#34;pdj 1&#34;</span>)[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#39;opcode&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># if its a jne, change it to its</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># non-conditional form</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;jne&#39;</span> <span style="color:#f92672">in</span> opcode:
</span></span><span style="display:flex;"><span>                    r2<span style="color:#f92672">.</span>cmd(<span style="color:#e6db74">&#34;wao nocj&#34;</span>)</span></span></code></pre></div>The full script can be downloaded <a href="https://github.com/ulexec/ulexec.github.io/raw/master/files/remove_xtunnel_ops.py">here</a></p>
<p>After applying this script we can obtain results as follows (function at 0x40A6A0):</p>
<p><img src="/x-tunnel_ops.png#center" alt="">
<!-- raw HTML omitted --></p>
<p>This approach can work for deterministic opaque perdicates although it has the following limitations:</p>
<ul>
<li>Path exploration algorithm can be very slow.</li>
<li>SMT solver may have difficulties to solve specific contraints such as cryptographic schemes or hashing algorithms.</li>
<li>Possibility of Path Explosion if input-dependant loops or recursion are found among other <a href="https://arxiv.org/pdf/1908.01549.pdf">techniques</a>.</li>
</ul>
<p>There are known attacks against Symbolic Execution Analysis:</p>
<ul>
<li>Input Dependant loops.</li>
<li>Range Dividers.</li>
</ul>
<p>Another approach to detect opaque predicates: Abstract Interpretation (TODO. Some nice <a href="https://www.msreverseengineering.com/blog/2018/2/26/concrete-and-abstract-interpretation-explained-through-chess">reference</a> by Rolf Rolles)</p>
<p>In the following section we will cover an approach to detect Range Dividers and how we can circumvent them.</p>
<!-- raw HTML omitted -->
<h2 id="range-dividers">Range Dividers<a href="#range-dividers" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="https://www.researchgate.net/publication/311491954_Code_obfuscation_against_symbolic_execution_attacks">Range dividers</a> are branch conditions that can be inserted at an arbitrary position inside a basic block, such that they divide the input range into multiple sets.</p>
<p>A simple example to illustrate this technique can be shown below:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">strlen</span>(str); str<span style="color:#f92672">++</span> , i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> chr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>str <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x20</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (chr) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                hash <span style="color:#f92672">=</span> (hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">^</span> chr;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                hash <span style="color:#f92672">=</span> (hash <span style="color:#f92672">*</span> <span style="color:#ae81ff">128</span>) <span style="color:#f92672">^</span> chr;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>     <span style="color:#75715e">// obfuscated version of case 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>    <span style="color:#75715e">// obfuscated version of case 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>In contrast to opaque predicates, range divider predicates may have multiple branches, any of which could be true and false depending on program input. This will cause symbolic execution engines to explore all branches of a range divider.</p>
<ul>
<li>Branch execution is dependant on an input value</li>
<li>All predicate branches have the same semantic meaning</li>
<li>Robust against Symbolic Execution/Abstract Interpretation</li>
<li>Almost like a n-way Opaque Predicate</li>
</ul>
<p>The eï¬€ectiveness of a range divider predicate against symbolic execution depends on:</p>
<ul>
<li>Number of branches of the predicate</li>
<li>The number of times the predicate is executed</li>
</ul>
<!-- raw HTML omitted -->
<h3 id="circumvention-2">Circumvention<a href="#circumvention-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>An approach to identify Range Dividers is by Semtantic Equivalence Checking.
Semantic Equivalence is an apporach to identify if two given sets of instructions have the same behavior based on the following premise:</p>
<ul>
<li>Same Code: Syntactically Equivalent</li>
<li>Same Behavior: Semantically Equivalent</li>
</ul>
<p>How it works:</p>
<ul>
<li>Perform Symbolic Execution per basic block on a given function.</li>
<li>Check for basic blocks semantic and syntactic equivalence within a given function.</li>
<li>Can be also seen as Semantic basic block diffing</li>
</ul>
<!-- raw HTML omitted -->
<h4 id="practical-example-deobfuscating-asprox-range-dividers">Practical Example. Deobfuscating Asprox Range Dividers<a href="#practical-example-deobfuscating-asprox-range-dividers" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>The binary file we are going to use for this example is the following:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Asprox: c56792bea8ac5fbf893ae3df1be0c3c878a615db6b24fd5253e5cbbc2e3e1dd3</span></span></code></pre></div>
The first thing we have to do is to retrieve all blocks from the subject obfuscated function.
Then we should compare for syntactic and semantic equivalence every block in the funtion with one another.
We can do this as follows:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># enumerate all blogs in target function</span>
</span></span><span style="display:flex;"><span>    target_blocks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> cn, block <span style="color:#f92672">in</span> enumerate(asmcfg<span style="color:#f92672">.</span>blocks):
</span></span><span style="display:flex;"><span>        target_blocks<span style="color:#f92672">.</span>append(block)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    results <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># iterate over all blocks to select src block</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> src_blk <span style="color:#f92672">in</span> target_blocks:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># retrieve src block label from src block</span>
</span></span><span style="display:flex;"><span>        src_ldl <span style="color:#f92672">=</span> src_blk<span style="color:#f92672">.</span>_loc_key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Skip a basic blocks containing only single instruction</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(src_blk<span style="color:#f92672">.</span>lines) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> src_blk<span style="color:#f92672">.</span>lines[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>dstflow():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># iterate through all blocks again</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># to select dst block</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> dst_blk <span style="color:#f92672">in</span> target_blocks:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># retrieve dst block label from dst block</span>
</span></span><span style="display:flex;"><span>            dst_ldl <span style="color:#f92672">=</span> dst_blk<span style="color:#f92672">.</span>_loc_key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Skip a basic block containing only single instruction</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(dst_blk<span style="color:#f92672">.</span>lines) <span style="color:#f92672">&lt;</span> <span style="color:#f92672">==</span>  <span style="color:#f92672">and</span> dst_blk<span style="color:#f92672">.</span>lines[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>dstflow():
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Skip if src and dst block are the same block</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> src_ldl <span style="color:#f92672">==</span> dst_ldl:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Skip if src and dst blocks have already been matched</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (src_ldl, dst_ldl) <span style="color:#f92672">in</span> results<span style="color:#f92672">.</span>keys() <span style="color:#f92672">or</span> \
</span></span><span style="display:flex;"><span>                    (dst_ldl, src_ldl) <span style="color:#f92672">in</span> results<span style="color:#f92672">.</span>keys():
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Check for syntax equivalence</span>
</span></span><span style="display:flex;"><span>            r_syntax <span style="color:#f92672">=</span> syntax_compare(src_blk, dst_blk)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> r_syntax:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># If the syntax of two blocks is same, then the semantics of them is also same.</span>
</span></span><span style="display:flex;"><span>                r_semantic <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Check for semantic equivalence</span>
</span></span><span style="display:flex;"><span>                r_semantic <span style="color:#f92672">=</span> semantic_compare(src_blk, dst_blk, ir_arch0, ir_arch1, asmcfg)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># save results of syntax and semantic checks</span>
</span></span><span style="display:flex;"><span>            results[(src_ldl, dst_ldl)] <span style="color:#f92672">=</span> [(r_syntax, r_semantic)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span></span></span></code></pre></div>
Syntactic equivalence is fairly straight forward, for this we don&rsquo;t even need to lift the subject block into IR.
This is how it can be implemented:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">syntax_compare</span>(blk0, blk1):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if blocks do not contain the same</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># number of instructions return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(blk0<span style="color:#f92672">.</span>lines) <span style="color:#f92672">!=</span> len(blk1<span style="color:#f92672">.</span>lines):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># iterate through all instructions in blocks</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> l0, l1 <span style="color:#f92672">in</span> zip(blk0<span style="color:#f92672">.</span>lines, blk1<span style="color:#f92672">.</span>lines):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if intruction is a branch</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> str(l0)[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;J&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># retrieve instruction opcode</span>
</span></span><span style="display:flex;"><span>            instr0 <span style="color:#f92672">=</span> str(l0)<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            instr1 <span style="color:#f92672">=</span> str(l1)<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> instr0 <span style="color:#f92672">!=</span> instr1:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># any other instruction</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> str(l0) <span style="color:#f92672">!=</span> str(l1):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span></span></span></code></pre></div>
On the other hand, for Semantic equivalence its slightly more complicated:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">semantic_compare</span>(blk0, blk1, ir_arch0, ir_arch1, asmcfg, flag_cmp<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create empty IR CFG for src block</span>
</span></span><span style="display:flex;"><span>    src_ircfg <span style="color:#f92672">=</span> IRCFG(<span style="color:#66d9ef">None</span>, ir_arch0<span style="color:#f92672">.</span>loc_db)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># add src block to empty IR CFG</span>
</span></span><span style="display:flex;"><span>        ir_arch0<span style="color:#f92672">.</span>add_asmblock_to_ircfg(blk0, src_ircfg)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">NotImplementedError</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create empty IR CFG for dst block</span>
</span></span><span style="display:flex;"><span>    dst_ircfg <span style="color:#f92672">=</span> IRCFG(<span style="color:#66d9ef">None</span>, ir_arch1<span style="color:#f92672">.</span>loc_db)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># add dst block to empty IR CFG</span>
</span></span><span style="display:flex;"><span>        ir_arch1<span style="color:#f92672">.</span>add_asmblock_to_ircfg(blk1, dst_ircfg)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">NotImplementedError</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if blocks were added to their IRCFG correctly</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(src_ircfg<span style="color:#f92672">.</span>blocks) <span style="color:#f92672">!=</span> len(dst_ircfg<span style="color:#f92672">.</span>blocks):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> src_lbl, dst_lbl <span style="color:#f92672">in</span> zip(src_ircfg<span style="color:#f92672">.</span>blocks, dst_ircfg<span style="color:#f92672">.</span>blocks):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># retrieve both src and dst blocks from their labels</span>
</span></span><span style="display:flex;"><span>        src_irb <span style="color:#f92672">=</span> src_ircfg<span style="color:#f92672">.</span>blocks<span style="color:#f92672">.</span>get(src_lbl, <span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>        dst_irb <span style="color:#f92672">=</span> dst_ircfg<span style="color:#f92672">.</span>blocks<span style="color:#f92672">.</span>get(dst_lbl, <span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># symbolically execute them to evaluate</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># semantic equivalence</span>
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> execute_symbolic_execution(
</span></span><span style="display:flex;"><span>                            src_irb, dst_irb,
</span></span><span style="display:flex;"><span>                            ir_arch0, ir_arch1,
</span></span><span style="display:flex;"><span>                            src_ircfg, dst_ircfg,
</span></span><span style="display:flex;"><span>                            flag_cmp)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> r <span style="color:#f92672">is</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span></span></span></code></pre></div>
We lift both of the ASMBlock into IR ones (IRBlock of AssignBlocks) and then we symbolically execute them.
In order to sucessfully symbolically execute both of them, some default setup for each IR block has to be done:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Initialize symbol context with register context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, r <span style="color:#f92672">in</span> enumerate(all_regs_ids):
</span></span><span style="display:flex;"><span>        src_symbols[r] <span style="color:#f92672">=</span> all_regs_ids_init[i]
</span></span><span style="display:flex;"><span>        dst_symbols[r] <span style="color:#f92672">=</span> all_regs_ids_init[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Instantiate Symbolic Execution Engine for src block</span>
</span></span><span style="display:flex;"><span>    src_sb <span style="color:#f92672">=</span> SymbolicExecutionEngine(ir_arch0, src_symbols)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># for each IR instruction in src block</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> assignblk <span style="color:#f92672">in</span> src_irb:
</span></span><span style="display:flex;"><span>        skip_update <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># retrieve IR expression and operand in block</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> dst, src <span style="color:#f92672">in</span> viewitems(assignblk):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If operand involves EIP or ret</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> str(dst) <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;EIP&#39;</span>, <span style="color:#e6db74">&#39;IRDst&#39;</span>]:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># skip symbolic execution</span>
</span></span><span style="display:flex;"><span>                skip_update <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># otherwise symbolically execute IR expression</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> skip_update:
</span></span><span style="display:flex;"><span>            src_sb<span style="color:#f92672">.</span>eval_updt_assignblk(assignblk)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Instantiate Symbolic Execution Engine for dest block</span>
</span></span><span style="display:flex;"><span>    dst_sb <span style="color:#f92672">=</span> SymbolicExecutionEngine(ir_arch1, dst_symbols)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># retrieve IR expression and operand in block</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> assignblk <span style="color:#f92672">in</span> dst_irb:
</span></span><span style="display:flex;"><span>        skip_update <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># If operand involves EIP or ret</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> dst, src <span style="color:#f92672">in</span> viewitems(assignblk):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> str(dst) <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;EIP&#39;</span>, <span style="color:#e6db74">&#39;IRDst&#39;</span>]:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># skip symbolic execution</span>
</span></span><span style="display:flex;"><span>                skip_update <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> skip_update:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># otherwise symbolically execute IR expression</span>
</span></span><span style="display:flex;"><span>            dst_sb<span style="color:#f92672">.</span>eval_updt_assignblk(assignblk)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set stack top for each symbolic engine</span>
</span></span><span style="display:flex;"><span>    src_sb<span style="color:#f92672">.</span>del_mem_above_stack(ir_arch0<span style="color:#f92672">.</span>sp)
</span></span><span style="display:flex;"><span>    dst_sb<span style="color:#f92672">.</span>del_mem_above_stack(ir_arch1<span style="color:#f92672">.</span>sp)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span></span></span></code></pre></div>
As we can see we have to configure the symbols we desire to symbolize, create one symbolic instance per block, Symbolically execute block and set up the top of the stack of each symbolic engine.</p>
<p>When this is done then we can start checking for semantic equivalence by evaluating each of the symbol&rsquo;s contraints of each symbolically executed block:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e"># Retrieve all memory accesses from src and dst symbolic engines</span>
</span></span><span style="display:flex;"><span>    all_memory_ids <span style="color:#f92672">=</span> [k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> dst_sb<span style="color:#f92672">.</span>symbols<span style="color:#f92672">.</span>memory()] <span style="color:#f92672">+</span> [k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> src_sb<span style="color:#f92672">.</span>symbols<span style="color:#f92672">.</span>memory()]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># iterate through all register and memory symbols</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># from both symbolic engines</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> all_regs_ids <span style="color:#f92672">+</span> all_memory_ids:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># keep iterating if symbol is EIP</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> str(k) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;EIP&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># keep iterating if symbol is eflags</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> flag_cmp <span style="color:#f92672">and</span> k <span style="color:#f92672">in</span> [zf, nf, pf, of, cf, af, df, tf]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># retrieve value of symbol from each symbolic engine</span>
</span></span><span style="display:flex;"><span>        v0 <span style="color:#f92672">=</span> src_sb<span style="color:#f92672">.</span>symbols[k]
</span></span><span style="display:flex;"><span>        v1 <span style="color:#f92672">=</span> dst_sb<span style="color:#f92672">.</span>symbols[k]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># keep iterating if symbol value is the same</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> v0 <span style="color:#f92672">==</span> v1:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># instantiate z3 SAT solver</span>
</span></span><span style="display:flex;"><span>        solver <span style="color:#f92672">=</span> z3<span style="color:#f92672">.</span>Solver()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># translate src symbol constraints to z3 readable form</span>
</span></span><span style="display:flex;"><span>            z3_r_cond <span style="color:#f92672">=</span> Translator<span style="color:#f92672">.</span>to_language(<span style="color:#e6db74">&#39;z3&#39;</span>)<span style="color:#f92672">.</span>from_expr(v0)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">NotImplementedError</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># translate dst symbol constraints to z3 readable form</span>
</span></span><span style="display:flex;"><span>            z3_l_cond <span style="color:#f92672">=</span> Translator<span style="color:#f92672">.</span>to_language(<span style="color:#e6db74">&#39;z3&#39;</span>)<span style="color:#f92672">.</span>from_expr(v1)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">NotImplementedError</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># add equality condition to solver</span>
</span></span><span style="display:flex;"><span>        solver<span style="color:#f92672">.</span>add(z3<span style="color:#f92672">.</span>Not(z3_r_cond <span style="color:#f92672">==</span> z3_l_cond))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if condition was unsatisfiable</span>
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> solver<span style="color:#f92672">.</span>check()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> r <span style="color:#f92672">==</span> z3<span style="color:#f92672">.</span>unsat:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># IR expression were equivalent</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># keep iterating</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span></span></span></code></pre></div>
After this we will have a list of all function&rsquo;s blocks evaluation with each other in terms of syntactic and semantic equivalence:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># save results of syntax and semantic checks</span>
</span></span><span style="display:flex;"><span>results[(src_ldl, dst_ldl)] <span style="color:#f92672">=</span> [(r_syntax, r_semantic)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span></span></span></code></pre></div>
Having this we can create a graph based on this relationship and utilize it to mark the equivalent blocks in a given subject function:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create graph</span>
</span></span><span style="display:flex;"><span>    G <span style="color:#f92672">=</span> nx<span style="color:#f92672">.</span>Graph()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># add nodes</span>
</span></span><span style="display:flex;"><span>    G<span style="color:#f92672">.</span>add_nodes_from(target_blocks)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># add edges based on syntax/semantic equivalence</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> viewitems(results):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if blocks have syntactic or semantic equivalence</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> v[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">or</span> v[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># add edge on block labels</span>
</span></span><span style="display:flex;"><span>            G<span style="color:#f92672">.</span>add_edge(k[<span style="color:#ae81ff">0</span>], k[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    random_colors <span style="color:#f92672">=</span> gen_random_color()
</span></span><span style="display:flex;"><span>    body <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Iterate through the blocks which are equivalent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> n, conn_nodes <span style="color:#f92672">in</span> enumerate(nx<span style="color:#f92672">.</span>connected_components(G)):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(conn_nodes) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> node <span style="color:#f92672">in</span> conn_nodes:  <span style="color:#75715e"># node is asmblk</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># set the same color for equivalent nodes</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> isinstance(node, LocKey):
</span></span><span style="display:flex;"><span>                asmblk <span style="color:#f92672">=</span> asmcfg<span style="color:#f92672">.</span>loc_key_to_block(node)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> asmblk:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> asmblk<span style="color:#f92672">.</span>lines:
</span></span><span style="display:flex;"><span>                        body <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;SetColor(0x</span><span style="color:#e6db74">%08x</span><span style="color:#e6db74">, CIC_ITEM, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">);</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (l<span style="color:#f92672">.</span>offset, random_colors[n])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> node<span style="color:#f92672">.</span>lines:
</span></span><span style="display:flex;"><span>                    body <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;SetColor(0x</span><span style="color:#e6db74">%08x</span><span style="color:#e6db74">, CIC_ITEM, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">);</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (l<span style="color:#f92672">.</span>offset, random_colors[n])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    header <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#include &lt;idc.idc&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static main()
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    footer <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    f <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;eq-color.idc&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(header <span style="color:#f92672">+</span> body <span style="color:#f92672">+</span> footer)
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>close()</span></span></code></pre></div>The full script can be downloaded <a href="https://github.com/ulexec/ulexec.github.io/raw/master/files/range_divider_detector.py">here</a></p>
<p>After applying the previous script to a given obfuscated function (0x10009B82) and slightly refine the results, we can obtain the following:</p>
<p><img src="/asprox_range_divider.png#center" alt="">
<!-- raw HTML omitted --></p>
<p>After this is trivial to remove the range divider predicates from the subject function. All we need is to identify the initial conditional branch that diverges into each individual predicate and apply the correspondent chnages to it appropietly.
The following are the before and after effects:</p>
<p><img src="/asprox_range_divider2.png#center" alt="">
<!-- raw HTML omitted --></p>
<p>In the particular case of Asprox I found that it wasn&rsquo;t implementing a high number of Range Divider predicates, usually two. Therefore it was trivial to clean the code after identifying them.
All needed to do was to either patch the intial conditional branch that diverges into each individual predicate so that it becomes unconditional or patch the conditional branch in a way so that it becomes NOPed.
We can apply either of these approaches accordingly to chose the predicate that will drive the control flow and remove the remaining ones.</p>
<p>Is also important to emphasize that the Range Divider cleaning process may not be as trivial if higher numbers of predicates where encountered or if the structure of the predicates would make each predicate to overlap with one another. Also lets not forget that this approach is assuming that the correct comparison unit is a basic block, which is true for Asprox predicates but is not necessarily generic. For example Tigress obfuscator implements Range Divider predicates on a function granuality. Therefore, this approach wont work, but could be adapted to support Tigress predicates re-defining the granuality for comparison and equivalence computation.</p>
<p>To finish this section on a high note, we can see that by marking blocks from a given function based on syntax and semantic equivalence can help us to indentify this obfuscation technique.</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Ignacio Sanmillan</span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
